
#MySQL

## MySQL基础知识

* In MySQL, schema = database
* 约束更是一个逻辑上的概念，用来保证数据的完整性；而索引是一个数据结构，既有逻辑上的概念，在数据库中还代表着物理存储的方式
* InnoDB 页大小16KB



## Sql执行顺序

```
1.  FROM 子句 组装来自不同数据源的数据
2.  WHERE 子句 基于指定的条件对记录进行筛选
3.  GROUP BY 子句 将数据划分为多个分组
4.  使用聚合函数进行计算
5.  使用HAVING子句筛选分组
6.  计算所有的表达式
7.  使用ORDER BY对结果集进行排序
8.  select 获取相应列
9.  limit截取结果集


```




## 两种存储引擎的区别
* MyISAM
    - MyISAM是MySQL的默认数据库引擎（5.5版之前）
    - 不支持行锁(MyISAM只有表锁)，读取时对需要读到的所有表加锁，写入时则对表加排他锁；
    - 不支持事务
    - 不支持外键
    - 不支持崩溃后的安全恢复
    - 在表有读取查询的同时，支持往表中插入新纪录
    - 支持BLOB和TEXT的前500个字符索引，支持全文索引
    - 支持延迟更新索引，极大地提升了写入性能
    - 对于不会进行修改的表，支持 压缩表 ，极大地减少了磁盘空间的占用

* InnoDB
    - InnoDB是MySQL的默认数据库引擎（5.5版之后）
    - 支持行锁，采用 MVCC（Multi-Version Concurrency Control 多版本并发控制）来支持高并发，有可能死锁
    - 支持事务
    - 支持外键
    - 支持崩溃后的安全恢复
    - InnoDB 1.2.x版本开始支持全文检索 

*  MyISAM 强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能

## 锁
* 表级锁： 每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
* 行级锁： 每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；


## MVCC的实现
* 快照读
* 当前读
* 只有在 Read Committed和Repeatable Read隔离级别下 生效




### 事务的ACID属性
* atomicity（redo log完成） 事务的原子性表示事务执行过程中，把事务作为一个工作单元处理，一个工作单元可能包括若干个操作步骤，每个操作步骤都
  必须完成才算完成，若因任何原因导致其中的一个步骤操作失败，则所有步骤操作失败，前面的步骤必须回滚。
* consistency（undo log完成） 事务的一致性保证数据处于一致状态。如果事务开始时系统处于一致状态，则事务结束时系统也应处于一致状态，不管事务成功还是失败
* Isolation（锁来完成） 事务的隔离性保证事务访问的任何数据不会受到其他事务所做的任何改变的影响，直到该事务完成
* Durability（redo log完成） 事务的持久性保证加入事务执行成功，则它在系统中产生的结果应该是持久的

### 三大范式
* 第一范式1NF：字段原子性 
    - 关系型数据库，默认满足第一范式
    - 必须不包含重复组的关系，即每一列都是不可拆分的原子项
* 第二范式2NF：消除对主键的部分依赖
    - 关系模式必须满足第一范式，并且所有非主属性都完全依赖于主码。
      注意，符合第二范式的关系模型可能还存在数据冗余、更新异常等问题。
    - 即在表中加上一个与业务逻辑无关的字段作为主键
* 第三范式3NF：消除对主键的传递依赖
    - 关系模型满足第二范式，所有非主属性对任何候选关键字都不存在传递依赖。
      即每个属性都跟主键有直接关系而不是间接关系
    


如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目

```mysql
# 检索记录行 6-15
SELECT * FROM table LIMIT 5,10;  
# 为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： 
 SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.
# 如果只给定一个参数，它表示返回最大的记录行数目： 
SELECT * FROM table LIMIT 5;     //检索前 5 个记录行
//换句话说，LIMIT n 等价于 LIMIT 0,n。

```


### 四种事务隔离级别
* read uncommitted （未提交读）
    - 读到未提交的数据：一个事务读到了另一个未提交事务修改过的数据，会脏读
* read committed （已提交读）
    - 脏读，不可重复读 一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，
      该事务都能查询得到最新值
* repeatable read（MySQL默认） 可重复读
    - 一个事务只能读到另一个已经提交的事务修改过的数据，但是第一次读过某条记录后，即使其他事务修改了该记录的值并且提交，
      该事务之后再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据
    - MySQL  InnoDB 存储引擎是可以阻止幻读的，通过MVCC来实现
* serializable 串行化


* 不可重复读的重点是修改，幻读的重点在于新增或者删除。不可重复度和幻读区别：
不可重复读的重点是修改，幻读的重点在于新增或者删除。

    READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
    READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
    REPEATABLE-READ(可重复读)：  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
    SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

BUT!!! Mysql 的 repeatable read 可以阻止幻读
InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。


### 索引
* B+树索引
    - B+树索引并不能找到一个给定键值的具体行，能找到的只是被查找数据所在的页。然后数据库通过把页
      读入内存，再在内存中进行查找，最后得到要查找的数据
    - 选用B+树这种数据结构作为索引，可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，
      并且B+树里的元素也是有序的。
* 全文索引
* 哈希索引


* m 阶B树的特性
    - 树中每个节点至多包含m棵子树
    - 若根节点不是叶子节点，则至少包含两颗子树
    - 除根以外的所有非终点节点至少有 (m/2)向上取整棵子树
    - 支持范围查询，前缀匹配查询，等值查询，可以避免排序，例如order by index相关的列，排序会非常快，因为该列本身就是
    - 有序存储的，查找时间复杂度 log m N(m为底,N的对数，N为总记录数)


* 为什么不使用hash索引而使用B+树索引呢？
    - 只支持包括 “=” "in "在内的等值查询，不支持范围，前缀匹配查询
    - 支持范围查询，前缀匹配查询，等值查询，可以避免排序，例如order by index相关的列，排序会非常快，因为该列本身就是

* B-树和B+树的区别在于B+树所有键值全部保存在叶子节点，而B-树则不然，B-树的键值根据树的结构分布在整个树上。

* Mysql为什么要采用B+树索引呢？
     1.遍历方便.B+树可以将键值保存在（线性表【数组或链表】）中，遍历线性表比索引树要快，因为保存在线性表中数据存储更加密集，B-Tree分散的
     存储会导致更多的随机I/O,对于磁盘访问，随机I/O是比顺序I/O慢很多的，因为随机I/O需要额外的磁头寻道操作。顺序I/O有效减少寻道的次数
     2.插入更新索引树时可以避免移动节点.
     3.遍历任何节点的时间复杂度相同，即访问路径总是从根节点到叶子节点.相比B-树,访问时间略长.所以某些高频访问的搜索采用B-树，即访问频率越高
     使其距离根节点越近。
     4.（也许是最重要的）范围查找方便。对于[A,B]区间的范围查找，B-树索引可以直接找到A,B对应的线性表中节点，只需要返回区间的所有节点
     即为目标结果。而B-树则稍显麻烦需要继续遍历索引树



### 服务器状态统计命令
* SHOW PROCESSLIST 显示了当前连接到 MYSQL 的连接或者线程的状态，
* SHOW PROFILE 可以高精度的记录每个查询语句在运行过程中各个操作的执行时间




## 分库分表

* 分库分表的原因
    - 并发支撑情况
    - 磁盘使用情况
    - SQL 执行性能


* 分布式ID 的处理
    - UUID
    - 自增ID
    - snowflake 算法
    


* UUID 坏处
    - 好处就是本地生成，不要基于数据库来了；不好之处就是，UUID 太长了、占用空间大，作为主键性能太差了；
    - 更重要的是，UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写），
    - 还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，
    在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。
    - 适合的场景：如果你是要随机生成个什么文件名、编号之类的，你可以用 UUID，但是作为主键是不能用 UUID 的。
    - UUID.randomUUID().toString().replace("-", "") -> sfsdf23423rr234sfdaf
    

* snowflake 算法
    - 时间戳 + 机房ID + 机器ID + 序列号
    - snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit
     是不用的，用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。
    - 1 bit：不用，为啥呢？因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。
    - 41 bit：表示的是时间戳，单位是毫秒。41 bit 可以表示的数字多达 2^41 - 1，也就是可以标识 2^41 - 1 个毫秒值，换算成年就是表示69年的时间。
    - 10 bit：记录工作机器 id，代表的是这个服务最多可以部署在 2^10台机器上哪，也就是1024台机器。但是 10 bit 里 5 个 bit 代表机房 id，5 个 bit
     代表机器 id。意思就是最多代表 2^5个机房（32个机房），每个机房里可以代表 2^5 个机器（32台机器）。
    - 12 bit：这个是用来记录同一个毫秒内产生的不同 id，12 bit 可以代表的最大正整数是 2^12 - 1 = 4096，也就是说可以用这个 12 bit
     代表的数字来区分同一个毫秒内的 4096 个不同的 id。
















## 狸猫的技术窝
* Buffer Pool  默认大小128MB，可以增大到2GB， 一般设置为机器内存的 50-60%
* Buffer Pool 缓存机制，free链表 flush 链表 lru 链表

```
show engine innodb status

```



todo 
lesson 24





