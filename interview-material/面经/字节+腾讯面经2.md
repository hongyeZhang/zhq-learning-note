
## 计算机网络
### TCP相关基础知识
* 三次握手状态图，为什么需要三次？
    - 客户端 A  服务器 B
        - (1)A发出连接请求报文（SYN=1,seq=x），并进入SYN-SENT（同步已发送）状态。
        - (2)B收到请求报文后，向A发送确认(ACK=1,ack=x+1,seq=y,SYN=1),进入到SYN-RCVD（同步收到）状态。
        - (3)A收到B的报文后，发送确认（ACK=1,ack=y+1,seq=x+1），A B 均进入建立连接状态(ESTABLISHED)。
    - 需要第三次的原因
        - 防止已经失效的连接请求报文被传送到B，因而产生错误（B错误的建立了连接，但是A并不发数据，造成了资源的浪费）

* 四次挥手的状态图，为什么需要四次？
    - 客户端 A  服务器 B
    - (1) A 向 B 发送连接释放报文(FIN=1, seq=u)，进入FIN-WAIT-1状态，停止向B发送数据
    - (2) B 收到连接释放报文之后，发送确认报文(ACK=1,ack=u+1,seq=v)，B进入关闭等待状态(CLOSED-WAIT)，至此，由 A->B 方向的连接释放，TCP
          连接处于半关闭状态。A 收到B的报文后，进入终止等待2(FIN-WAIT-2)状态，等待B发出的连接释放报文。
    - (3) 如果B没有向A发送的数据，则发出连接释放报文(FIN=1,seq=w,ACK=1,ack=u+1), B 进入最后确认状态(LAST-ACK)
    - (4) A收到B的连接释放报文后，发送确认报文(ACK=1,ack=w+1,seq=u+1), 进入到时间等待状态(TIME-WAIT)，在等待 时间等待计时器 设置的 2MSL
         （最长报文段寿命） 时间后，进入关闭状态(CLOSED)。B 收到报文之后，就进入CLOSED状态，比A结束的早一点。
    - 四次挥手中TIME_WAIT状态存在的目的是什么?
        - (1)为了保证A最后发送的ACK能够达到B，因为如果发送的报文丢失，需要等待B的请求重传报文，然后将原报文重传
        - (2)为了保证本连接中所有的报文都从网络消失，防止一个新的TCP连接中出现旧的报文。
    - TCP 保活计时器的作用？
        - 防止在客户机与服务器之间建立连接之后，客户机发生故障，造成服务器的资源浪费。
        - 若服务器 2h 内没有受到客户机的数据，则会发送探测报文，如果一定条件下没有受到客户机的响应，则认为客户机出故障，关闭连接。

* TCP是通过什么机制保障可靠性的?
    - ACK确认机制，确认丢失，确认迟到，进行自动重传请求(ARQ automatic repeat request)
    - 重试重传，保留已发送但未确认报文的副本
    - 通过滑动窗口的控制
    - 选择确认 SACK
    
* TCP的流量控制
    - 利用滑动窗口实现流量控制。控制发送速率不能太快，要让接受方来的及接受。

* TCP的拥塞控制方法
    - 慢开始： 从小到大逐渐增大发送窗口，在达到慢开始门限之前，发送速度指数增长
    - 拥塞避免：达到慢开始门限之后，发送速度改为线性增长
    - 快重传：让发送方尽快知道发生了个别报文的丢失，如果连续收到接收方的3个重复确认请求，发送方应该立即重传，不会误以为产生网络堵塞
    - 快恢复：由于不是网络堵塞的原因产生的报文丢失，也就没有必要从慢开始进行传输，所以进行快恢复。调整慢开始门限，执行堵塞避免算法。

* 网络IO模型有哪些?
     - 5种网络I/O模型
         - 阻塞
         - 非阻塞
         - I/O多路复用
         - 信号驱动IO
         - 异步I/O

* 从数据从I/O设备到内核态，内核态到进程用户态分别描述这5种的区别。
    - TODO
    - 见HTML文件

* I/O多路复用中select/poll/epoll 的区别？
    - select、poll、epoll都是IO多路复用的模型。I/O多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个描述符就绪，能够通知应用程序进行相应操作。
    - select/poll 缺点
        - 每次调用select/poll都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；
        - 同时每次调用select/poll都需要在内核遍历传进来的所有fd，这个开销在fd很多时会很大；
        - select支持的文件描述符数量太小，默认1024；
        - select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；
        - select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知给进程
    - epoll 优点
       - epoll没有最大并发连接限制，上限是最大可以打开的文件的数目，这个数字远大于“2048”，具体数目可以cat /proc/sys/fs/file-max查看。
       - 效率提升，epoll最大的优点就在于它只管你活跃的连接，而跟连接总数无关，因此在实际的网络环境中，epoll的效率会远远高于select/poll。
       - 无内存拷贝，epoll在这点上使用了“共享内存”，这个内存拷贝也就省略了。

### HTTP相关基础
* 输入url到页面加载都发生了什么事情？
    - DNS解析
        - DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。
    - TCP连接
    - 发送HTTP请求
    - 服务器处理请求并返回HTTP报文
    - 浏览器解析渲染页面
    - 连接结束

* HTTP传输流
    - 应用层 -> 传输层 -> 网络层 -> 数据链路层 -> 物理层
    - 发送端每通过一层，则增加首部，接收端每通过一层删除首部 

* 客户端访问url到服务器，整个过程会经历哪些？
    - 从五层网络模型，HTTP -> TCP -> IP -> 链路 整个过程讲解报文的产生以及传递的过程

* HTTPS
    - HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，
      如果中间被截取的话会存在一些信息泄露的风险。
    - HTTPS协议的本质就是 HTTP + SSL (or TLS)。
    - 在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。
    - 从网络的层级结构看它位于HTTP协议与TCP协议之间。

* HTTPS过程
    - HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。
      TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客TLS/SSL握手过程。
    - HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要
      根据具体情况在安全和性能方面做出权衡。

* 描述 HTTPS 和 HTTP 的区别
    - https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
    - http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
    - http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
    - http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

* TCP 和 UDP的区别？


* HTTP协议的请求报文和响应报文格式
    - 请求报文
        -请求方法 + URL + 协议版本 + 请求首部字段【可选】 + 内容实体
    - 响应报文
        - 协议版本 + 状态码 + 用以解释状态的原因短语 + 响应首部字段【可选】 + 实体主体

* HTTP 常用方法
    - get 
    - post 
    - put 
    - delete

* POST 和 GET 的区别
    - 语义区别，GET 是获取数据，POST是提交数据
    - GET请求参数放在URL中，POST放在request body中
    - get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节），而post无限制
    - get请求会被保存，保存在浏览器历史记录中，还可能保存在web服务器的日志中
    - GET产生一个TCP数据包;POST产生两个TCP数据包。 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);
      而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。
    - GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息
    - GET请求只能进行url编码，而POST支持多种编码方式

* HTTP的状态码有哪些?
    - 1XX
        - 100 Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
        - 100     //继续  请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。
        - 101     //切换协议  请求者已要求服务器切换协议，服务器已确认并准备切换。
    - 2XX 成功
        - 200  OK   正常返回信息
        - 201  Created  请求成功并且服务器创建了新的资源
        - 202  Accepted  服务器已接受请求，但尚未处理
        - 200     //成功  服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页。
        - 201     //已创建  请求成功并且服务器创建了新的资源
        - 202     //已接受  服务器已接受请求，但尚未处理
        - 203     //非授权信息  服务器已经成功处理了请求，但返回的信息可能来自另一来源
        - 204     //无内容  服务器成功处理了请求，但没有返回任何内容
        - 205     //重置内容  服务器成功处理了请求，但没有返回任何内容
        - 206     //部分内容  服务器成功处理了部分GET请求
    - 3XX 重定向
        - 301  Moved Permanently  请求的网页已永久移动到新位置。
        - 302 Found  临时性重定向。
        - 303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。
        - 304  Not Modified  自从上次请求后，请求的网页未修改过。
        - 300     //多种选择  针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择。
        - 301     //永久移动  请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置。
        - 302     //临时移动  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
        - 303     //查看其它位置  请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码
        - 304     //未修改  自动上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容
        - 305     //使用代理  请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理
        - 307     //临时性重定向  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求
    - 4XX 客户端错误
        - 400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
        - 401 Unauthorized  请求未授权。
        - 403 Forbidden  禁止访问。
        - 404 Not Found  找不到如何与 URI 相匹配的资源。
        - 400     //错误请求  服务器不理解请求的语法
        - 401     //未授权  请求要求身份验证。对于需要登录的网页，服务器可能返回此响应
        - 403     //禁止  服务器拒绝请求
        - 404     //未找到  服务器找不到请求的网页
        - 405     //方法禁用  禁用请求中指定的方法
        - 406     //不接受  无法使用请求的内容特性响应请求的网页
        - 407     //需要代理授权  此状态码与401（未授权）类似，但指定请求者应当授权使用代理
        - 408     //请求超时  服务器等候请求时发生超时
        - 409     //冲突  服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。
        - 410     //已删除  如果请求的资源已永久删除，服务器就会返回此响应
        - 411     //需要有效长度  服务器不接受不含有效内容长度标头字段的请求
        - 412     //未满足前提条件  服务器未满足请求者在请求者设置的其中一个前提条件
        - 413     //请求实体过大  服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力
        - 414     //请求的URI过长  请求的URI（通常为网址）过长，服务器无法处理
        - 415     //不支持媒体类型  请求的格式不受请求页面的支持
        - 416     //请求范围不符合要求  如果页面无法提供请求的范围，则服务器会返回此状态码
        - 417     //未满足期望值  服务器未满足“期望”请求标头字段的要求
    - 5XX 服务器错误
        - 500 Internal Server Error  最常见的服务器端错误。该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障
        - 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。
        - 500 //服务器内部错误  服务器遇到错误，无法完成请求
        - 501 //尚未实施  服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码
        - 502 //错误网关  服务器作为网关或代理，从上游服务器无法收到无效响应
        - 503 //服务器不可用  服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态
        - 504 //网关超时  服务器作为网关代理，但是没有及时从上游服务器收到请求
        - 505 //HTTP版本不受支持  服务器不支持请求中所用的HTTP协议版本








* 要求描述HTTP的版本之间的区别，主要是1.0/1.1/2.0三个版本的区别。详细说了1.0与1.1之间是连接模型的区别(短连接、长连接、管线化)
，1.1与2.0之间的区别是I/O多路复用的单一长连接、服务器推送、二进制分桢、首部压缩等。



## HTTP请求方法
* HTTP有哪些方法？
    - HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法
    - HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT
    - HTTP/1.1 规定了八种方法，单词都必须是大写的形式
        - 1.GET：获取资源，可以理解为读取或者下载数据；
        - 2.HEAD：获取资源的元信息，即获取响应头。
        - 3.POST：向资源提交数据，相当于写入或上传数据；可以理解为新建（create）
        - 4.PUT：类似 POST；可以理解为更新，修改
        - 5.DELETE：删除资源；
        - 6.CONNECT：建立特殊的连接隧道；
        - 7.OPTIONS：列出可对资源实行的方法；
        - 8.TRACE：追踪请求 - 响应的传输路径。
    - 幂等：GET、HEAD、DELETE、PUT

* HTTP八种方法的具体作用是什么？
    - GET: 通常用于请求服务器发送某些资源
    - HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源
    - OPTIONS: 用于获取目的资源所支持的通信选项
    - POST: 发送数据给服务器
    - PUT: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式
    - DELETE: 用于删除指定的资源
    - PATCH: 用于对资源进行部分修改
    - CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
    - TRACE: 回显服务器收到的请求，主要用于测试或诊断

* GET和POST有什么区别？
    - 数据传输方式不同：GET请求通过URL传输数据，而POST的数据通过请求体传输。
    - 安全性不同：POST的数据因为在请求主体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息。
    - 数据类型不同：GET只允许 ASCII 字符，而POST无限制
    - GET无害： 刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交表单
    - 特性不同：GET是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），
      而POST是非安全非幂等

* PUT和POST都是给服务器发送新增资源，有什么区别？
    - PUT 和POST方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而POST方法是非幂等的。

* PUT和PATCH都是给服务器发送修改资源，有什么区别？
    - PUT和PATCH都是更新资源，而PATCH用来对已知资源进行局部更新。

* http的请求报文是什么样的？
请求报文有4部分组成:
    - 请求行
        - 请求方法字段、URL字段、HTTP协议版本字段。它们用空格分隔。例如，GET /index.html HTTP/1.1。
    - 请求头部
        - 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔
            - User-Agent：产生请求的浏览器类型。
            - Accept：客户端可识别的内容类型列表。
            - Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。
    - 空行
    - 请求体
        - post put等请求携带的数据

* http的响应报文是什么样的？
求报文有4部分组成:
    - 响应行
        - 由协议版本，状态码和状态码的原因短语组成，例如HTTP/1.1 200 OK
    - 响应头
        - 响应部首组成
    - 空行
    - 响应体
        - 服务器响应的数据

* HTTP的部首有哪些？
    - 【必看】面试官（9）：可能是全网最全的http面试答案 - 掘金

* HTTP的keep-alive是干什么的？
在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。
在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，
下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。
keep-alive的优点：

较少的CPU和内存的使用（由于同时打开的连接的减少了）
允许请求和应答的HTTP管线化
降低拥塞控制 （TCP连接减少了）
减少了后续请求的延迟（无需再进行握手）
报告错误无需关闭TCP连


* Https 加密原理



* UDP
    - 1.面向无连接
        - 首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。
        - 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
        - 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作
    - 2.有单播，多播，广播的功能
        - UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。
    - 3.UDP是面向报文的
        - 发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文
    - 4.不可靠性
        - 首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。
        - 并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。
        - 再者网络环境时好时坏，但是 UDP因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。
    - 5.头部开销小，传输数据报文时是很高效的。 只占8个字节， 源端口、目的端口、长度、校验和。





## 
* 自己设计hash函数
    - 将每个字符的 ASCII 码加起来，对 hash表的长度取余
    - 通过位运算
* hash冲突的解决方法
    - 分离连接法
    - 线性探测、平方探测
    - 再散列
