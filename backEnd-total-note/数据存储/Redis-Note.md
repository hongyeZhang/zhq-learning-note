# Redis学习笔记


## 《Redis设计与实现》学习笔记
### chapter2 简单动态字符串
* SDS (simple dynamic string) 简单动态字符串 保存数据库中的字符串值，不是直接使用C字符串，而是重新定义了一个struct
* 惰性空间释放策略，避免缩短时进行内存的重分配
* 可以复用 string.h 中的部分c的字符串处理函数

### chapter3 链表
* 双端链表
* 无环

### chapter4 字典
* redis数据库使用字典作为底层实现
* 哈希键的底层实现之一
* 哈希表通过链地址法解决冲突
* rehash通过 ht 中的 ht[0] ht[1] 配合完成
* 渐进式rehash，不是一次性完成的  rehashidx

### chapter5 跳跃表
* 跳跃表操作的时间复杂度：平均O(logN) 最差 O(N)，效率可以和平衡树媲美，大部分场景可以代替平衡树
* 作为有序集合的底层实现之一
* zskiplist zskiplistNode


### chapter6 整数集合（intset）
* 整数集合是集合键的底层实现之一
* 整数集合的底层实现为数组，以有序、无重复的方式保存集合元素
* 只支持升级操作，不支持降级操作


### chapter7 压缩列表
* ziplist 是列表键和哈希键的底层实现之一
* 为了节约内存而开发的顺序性数据结构
* 其他的没有仔细看 

### chapter8 对象
* redisObject 
* 键对象：字符串对象
* 值对象：字符串对象、列表对象、哈希对象、集合对象、有序集合对象
* 每种类型的对象都至少使用了两种类型的编码
* page63 每种类型的对象所有可能的编码方式
* 字符串对象的编码方式 int raw embstr
* 列表对象的编码方式  ziplist linkedlist
* 哈希对象的编码方式  ziplist hashtable
* 集合对象的编码方式  intset  hashtable
* 有序集合的编码方式  ziplist skiplist
* 执行命令之前会进行类型检查，确认操作的命令适合当前的数据结构
* redis五种常用的数据结构，每种结构有两种以上的编码方式
* 通过引用计数实现内存回收机制


### chapter9 数据库
* 一个服务器默认16个数据库，默认写0数据库
* expires 过期字典
* persist 移除一个键的过期时间
* ttl  pttl 计算并返回键的过期时间
* 过期键的删除策略
    * 定时删除【实际redis没有使用】  对于CPU是不友好的，会对服务器的响应时间和吞吐量造成影响
    * 惰性删除  对于内存是不友好的，一直不删除无用的键，甚至可以认为是内存泄漏
    * 定期删除  以上两种策略的折中，难点是确定删除的时间和频率。分多次遍历redis所有的数据库，从过期字典中随机选择一部分键的过期时间，并删除
* 数据库通知
    * 客户端订阅给定的通道和模式，获知数据库中键的变化，以及数据库中命令的执行情况
    * 键空间通知、键事件通知

### chapter10 RDB持久化
* save 和 bgsave 可以生成RDB文件
    * save 堵塞redis主进程，直到RDB文件创建成功为止，因为由服务器进程执行保存工作
    * bgsave  后台会派生出一个子进程，然后由子进程负责创建RDB文件
* 优先使用AOF的方式来回复数据库的数据
* 对于不同的键值对，RDB会使用不同的方式进行保存
* RDB通过保存数据库中的键值对记录数据库状态


### chapter11 AOF持久化
* AOF (append only file) 通过保存redis服务器执行的写命令来记录数据库的状态
* AOF持久化的F功能实现
    * 命令追加 append
    * 文件写入
    * 文件同步
* 可以配置刷新磁盘的策略：一直刷新、每秒钟刷新、从来不刷新
    * always 
    * everysec
    * no
* AOF重写，代替原来的AOF文件，减少冗余的命令，二者的内容一样
* 使用子进程进行AOF的重写，此时服务器进程（父进程）可以继续处理命令请求，
* AOF重写缓冲区，解决数据不一致的问题
* AOF中的所有命令都以redis命令请求协议的格式保存


### chapter12 事件
* redis服务器是一个事件驱动程序
    * 文件事件
    * 时间事件
* 文件事件处理器
    * 以单线程方式运行，通过I/O多路复用程序监听多个套接字
    * 组成：套接字、I/O多路复用程序、文件事件分派器、事件处理器












## 基础知识

Redis ，全称 Remote Dictionary Server ，是一个基于内存的高性能 Key-Value 数据库。

所有的redis操作都是原子的


（1）redis运行在内存中，数据量不能超过内存的大小，可以做很多内部复杂性很强的操作
（2）守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），
是 Linux 中的后台服务进程。它是一个生存期较长的进程，
通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件
（3）Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。
Redis是一个字典结构的存储服务器，而实际上一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。
这与我们熟知的在一个关系数据库实例中可以创建多个数据库类似，所以可以将其中的每个字典都理解成一个独立的数据库。

不同的应用应该使用不同的Redis实例存储数据
针对五种不同的数据类型，分别有对应的操作

（4）单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。
事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做


### 哨兵模式
主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。

一、哨兵模式概述
哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。
这里的哨兵有两个作用

通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。

当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。

然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。

用文字描述一下故障切换（failover）的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。

作者：秃头哥编程
链接：https://www.jianshu.com/p/06ab9daf921d
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

作者：秃头哥编程
链接：https://www.jianshu.com/p/06ab9daf921d
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### 基本命令

sudo vim /etc/redis/redis.conf

修改bind行，将127.0.0.1修改为*,配置远程可以访问

ubuntu启动Redis服务
service redis-server start
service redis-server status

以命令行方式进入Redis，分别为本地进入方式与远程进入方式：
redis-cli5
redis-cli -h 10.108.115.229 -p 6379

- 命令行查看:SMEMBERS HTTP_RESULT
- 命令行删除:del HTTP_RESULT

查看服务端redis版本
redis-server -v
redis-server --version





### 数据结构


## 什么是布隆过滤器
本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。
相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。

实现原理
HashMap 的问题
讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。

还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。

布隆过滤器数据结构
布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：
值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。

这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。

支持删除么
目前我们知道布隆过滤器可以支持 add 和 isExist 操作，那么 delete 操作可以么，答案是不可以，例如上图中的 bit 位 4 被两个值共同覆盖的话，一旦你删除其中一个值例如 “tencent” 而将其置位 0，那么下次判断另一个值例如 “baidu” 是否存在的话，会直接返回 false，而实际上你并没有删除它。

如何解决这个问题，答案是计数删除。但是计数删除需要存储一个数值，而不是原先的 bit 位，会增大占用的内存大小。这样的话，增加一个值就是将对应索引槽上存储的值加一，删除则是减一，判断是否存在则是看值是否大于0。

如何选择哈希函数个数和布隆过滤器长度
很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。

另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。

k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率。
至于如何推导这个公式，我在知乎发布的文章有涉及，感兴趣可以看看，不感兴趣的话记住上面这个公式就行了。

最佳实践
常见的适用常见有，利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。

另外，既然你使用布隆过滤器来加速查找和判断是否存在，那么性能很低的哈希函数不是个好选择，推荐 MurmurHash、Fnv 这些。

#### 大Value拆分
Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。
拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。


