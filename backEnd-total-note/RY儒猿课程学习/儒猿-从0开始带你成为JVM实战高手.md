# 从0开始带你成为JVM实战高手


## chapter2 一探究竟：我们写的Java代码到底是如何运行起来的？
* JVM 基于自己字节码执行引擎，执行加载到内存的类，比如代码中有 main 方法，就会从 main() 方法中开始执行，遇到需要执行的类，就加载到虚拟机。

![类的加载运行图](../picture/ruyuan/redis/类的加载运行图.png)


## chapter03 面试官对于 JVM 类加载机制的猛烈炮火，你能顶住吗？
* jvm在什么情况下会加载一个类？
    * 在代码中用到这个类的时候
    * 加载到使用的过程：加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载
    * 验证阶段：根据java虚拟机的规范，校验加载进来的.class文件的内容，是否符合虚拟机的规范，以防class文件被人修改过了
    * 准备阶段：给java类分配内容空间，给类里面的变量分配空间，给定默认的初始值
    * 解析阶段：将符号引用替换为直接引用的过程，具体的内容比较复杂，涉及到 jvm 的底层
    * 初始化阶段：准备阶段只是给类变量（比如 flushInterval）一个默认的初始值0，但是真正赋值语句的执行，是在初始化阶段完成
        * 类的初始化规则：
            * new ReplicaManager()，会出发类的加载和初始化全过程
            * 包含 main() 方法的类，会立即初始化
            * 如果初始化时，发现父类没有初始化，则立马初始化父类
* 类加载器和双亲委派机制
    * 类加载器
        * 启动类加载器：Bootstrap ClassLoader，主要负责加载我们在机器上安装的Java目录下的核心类的（Java安装目录下的“lib”目录中的核心类库）
        * 扩展类加载器：Extension ClassLoader，加载Java安装目录下的“lib\ext”
        * 应用程序类加载器 Application ClassLoader 加载“ClassPath”环境变量所指定的路径中的类，大致理解为加载你写好的Java代码，
           这个类加载器就负责加载你写好的那些类到内存里
        * 自定义类加载器 
            * JVM的类加载器是有亲子层级结构的，就是说启动类加载器是最上层的，扩展类加载器在第二层，第三层是应用程序类加载器，最后一层是自定义类加载器。
            * 双亲委派机制： 
                ![双亲委派机制.png](../picture/ruyuan/redis/双亲委派机制.png) 
                * 假设你的应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载
                    但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器    
                * 可以避免多层级的加载器结构重复加载某些类
                 
## chapter04 JVM中有哪些内存区域，分别都是用来干嘛的？
* JVM 内存区域划分
    * MetaSpace元数据空间（1.8以前为方法区）主要存放 类的相关信息，常量池等
    * 程序计数器：记录当前执行的字节码指令的位置，每个线程都会有一个程序计数器，记录线程目前执行到哪一条字节码指令
    * 虚拟机栈：保存方法内的局部变量等数据，每一个方法调用对应一个栈帧
    * 堆内存：存放代码中创建的各种对象
    * 其他内存区域：native方法（线程对应的本地方法栈等）
* tomcat 的类加载机制设置
    * 打破了双亲委派机制，每个WebApp负责加载自己对应的那部分web应用的class文件，不会传导到上层的加载器去加载

## chapter05 JVM的垃圾回收机制是用来干嘛的？为什么要垃圾回收？
* 我们创建的那些对象，到底在Java堆内存里会占用多少内存空间呢？
    * 一个对象对内存空间的占用，大致分为两块
        * 一个是对象自己本身的一些信息
        * 一个是对象的实例变量作为数据占用的空间(比如对象头，如果在64位的linux操作系统上，会占用16字节，然后如果你的实例对象内部有个int类型的
        实例变量，他会占用4个字节，如果是long类型的实例变量，会占用8个字节。如果是数组、Map之类的，那么就会占用更多的内存了。) 
            另外JVM对这块有很多优化的地方，比如补齐机制、指针压缩机制，比较复杂，不会详细梳理 
        

## chapter08 聊聊JVM分代模型：年轻代、老年代、永久代
* jvm 分代模型 年轻代、老年代、永久代
  * 大部分在我们代码里创建的对象，其实都是存活周期很短的。这种对象，其实在我们写的Java代码中，占到绝大部分的比例
  * 年轻代：很快就要被回收的对象
  * 老年代：长期存在的对象
  * 永久代：也就是方法区，主存放一些类的信息。
    * 方法区内是否会进行垃圾回收？
      * 首先该类的所有实例对象都已经从Java堆内存里被回收，其次加载这个类的ClassLoader已经被回收 ，最后对该类的Class对象没有任何引用
* jvm垃圾回收指的是新生代、老年代和方法区，不是针对方法的栈帧，栈帧在方法执行完毕之后就在内存中清除掉了

## chapter09 大厂面试题：你的对象在JVM内存中如何分配？如何流转的？
* 新生代
  * 大部分正常对象都优先在新生代分配内存
  * 如果新生代满了，会触发 YoungGC 或者 minorGC 回收掉没有引用的垃圾对象
  * 对象在新生代躲过了指定次数的垃圾回收，就会进入老年代
  * 

## chapter10 动手实验：亲自感受一下线上系统部署时如何设置JVM内存大小？
* JVM核心参数接解析以及如何设置 
  * -Xms：Java堆内存的大小，通常设置与 Xmx 一样大小
  * -Xmx：Java堆内存的最大大小 
  * -Xmn：Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小
  * -XX:PermSize（-XX:MetaspaceSize jdk1.8 元数据区）：永久代大小，通常与 MaxPermSize 设置一样大
  * -XX:MaxPermSize(-XX:MaxMetaspaceSize jdk1.8 元数据区)：永久代最大大小 
  * -Xss：每个线程的栈内存大小

## chapter11 案例实战：每日百万交易的支付系统，如何设置JVM堆内存大小？
* 分清楚系统的主要业务处理逻辑，计算核心链路的QPS峰值和对象大小,再扩大10-20倍,估计出每秒会产生多少对象,再分配堆内存的大小,同时可以估计出YoungGC的频率

## chapter12 案例实战：每日百万交易的支付系统，JVM栈内存与永久代大小又该如何设置？
* 如何设置永久代的大小？没有什么参考的规范，一般几百M是够用的

## chapter15 大厂面试题：什么情况下JVM内存中的一个对象会被垃圾回收？
* JVM使用可达性分析算法来确定哪些对象可以被回收，哪些对象不能够被回收。每个对象都去分析是否有对象引用他，一层层的判断是否有GC Roots
* GC Roots 的所有情况
  * 方法的局部变量
  * 类的静态变量
* java对象的不同引用类型
  * 强引用
    * 垃回收时不会主动回收这种引用对象
  * 软引用 SoftReference<Class>
    * 正常情况下垃圾回收不会回收软引用对象，但是如果在回收一遍之后发现剩余的内存仍然不够存放新的对象，就会把软引用对象回收掉
  * 弱引用 WeakReference<Class>
    * 跟没引用类似，如果发生的垃圾回收，就会把这个对象回收掉
  * 虚引用
    * 一般不使用
## chapter16 大厂面试题：JVM中有哪些垃圾回收算法，每个算法各自的优劣？
* 复制算法
  * 把新生代的内存分为两块区域，只使用其中的一块内存，回收的时候将所有的存活对象转移到另一块内存，两块区域反复使用
  * 缺点：对内存的使用效率太低了
* 复制算法升级：新生代划分 Eden、Survivor1、Survivor2区
  * eden:s1:s2=8:1:1 s1或者s2存放每次young GC 

## chapter17 大厂面试题：年轻代和老年代分别适合什么样的垃圾回收算法？
* -XX:MaxTenuringThreshold  设定经历多少次垃圾回收之后，对象由新生代进入老年代，默认为15次
* 动态年龄判断
  * 假如说当前放对象的Survivor区域里，一批对象的总大小大于了这块Survivor区域的内存大小的50%，那么此时大于等于这批对象年龄的对象，就可以直接进入老年代
* 大对象直接进入老年代
  * -XX:PretenureSizeThreshold 如果你要创建一个大于这个大小的对象，比如一个超大的数组，此时就直接把这个大对象放到老年代里去。压根儿不会经过新生代。