

分布式锁的条件：

分布式锁应该具备哪些条件
在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行
高可用的获取锁与释放锁
高性能的获取锁与释放锁
具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）
具备锁失效机制，防止死锁
具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败

# 分布式锁的实现有哪些
Memcached：利用 Memcached 的 add 命令。此命令是原子性操作，只有在 key 不存在的情况下，才能 add 成功，也就意味着线程得到了锁。
Redis：和 Memcached 的方式类似，利用 Redis 的 setnx 命令。此命令同样是原子性操作，只有在 key 不存在的情况下，才能 set 成功。
Zookeeper：利用 Zookeeper 的顺序临时节点，来实现分布式锁和等待队列。Zookeeper 设计的初衷，就是为了实现分布式锁服务的。
Chubby：Google 公司实现的粗粒度分布式锁服务，底层利用了 Paxos 一致性算法。

分布式锁的三个核心要素：加锁、解锁、锁超时
Redis
加锁:  setnx
解锁: del
锁超时：expire 一个服务获得锁之后宕机，资源一直被锁着，需要锁超时机制自动解锁。


单体应用中： 通过同步代码块有序的访问资源，分布式系统：多个进程使用分布式锁。
redis执行是单线程的，有序的

一、原子性
1.1 setnx、1.2 expire 非原子性操作，当setnx之后宕机了，容易死锁，所以这两步要原子性
解决方案：set(key, value, expire)

 二、误删锁
 set(key, value, expire) 因为某些原因，数据没有操作完，锁被释放掉了，此时另一个进程获取了锁之后，本进程的操作执行完了，再执行del命令，会删除另一个进程的锁。
 解决方案：删之前判断是不是自己的锁
 set(key, threadId, stock) value中设置自己的相关信息，如果是就删除，如果不是就不删除。

 三、基于前一个问题
 判断数据或否处理完成，数据完成之后才能释放锁。JVM1增加守护线程，处理线程+守护线程
 比如 超时时间30s，守护线程正在第29秒时，判断是否执行完成，如果没有处理完成，就加时20s
