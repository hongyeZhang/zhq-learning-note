
# 分布式事务学习笔记
https://www.bilibili.com/video/av80760547?p=2


## 事务
* 原子性（A）：原子性是指一个事务的所有操作，要么都做完，要么都不做。
* 一致性（C）：一致性是指一个事务的执行，不管外部环境如何，不管怎么执行，结果应该都是一致的。
* 隔离性（I）：隔离性是指几个事务在同时执行的时候，相互之间不会受影响。
* 持久性（D）：持久性就是事务完成以后，数据就被保存。

## 单系统跨着库事务
    使用两阶段提交来实现多个资源之间的事务，会带来很大的性能问题。因为要同步多个资源的事务，对每个资源使用
    两阶段提交，这就使得这个事务所花的时间比本地事务多很多。而且在这个时间段内，由于事务的隔离性，可能会造成长时间的
    资源占用，使得其它的事务无法同步访问该资源上的一些数据。

## 分布式事务
* 多系统微服务分布式事务


## XA/JTA 规范
    XA是由X/Open组织提出的分布式事务的架构（或者叫协议）。XA架构主要定义了（全局）事务管理器（Transaction Manager）
    和（局部）资源管理器（Resource Manager）之间的接口。XA接口是双向的系统接口，在事务管理器（Transaction Manager）
    以及一个或多个资源管理器（Resource Manager）之间形成通信桥梁。也就是说，在基于XA的一个事务中，我们可以针对多个资源
    进行事务管理，例如一个系统访问多个数据库，或即访问数据库、又访问像消息中间件这样的资源。这样我们就能够实现在多个数据库
    和消息中间件直接实现全部提交、或全部取消的事务。XA规范不是java的规范，而是一种通用的规范，
    
    JTA(Java Transaction API)，是J2EE的编程接口规范，它是XA协议的JAVA实现。它主要定义了：
    一个事务管理器的接口javax.transaction.TransactionManager，定义了有关事务的开始、提交、撤回等操作。
    一个满足XA规范的资源定义接口javax.transaction.xa.XAResource，一种资源如果要支持JTA事务，就需要让它的资源
    实现该XAResource接口，并实现该接口定义的两阶段提交相关的接口。
    
    JTA的优点很明显，就是提供了分布式事务的解决方案，严格的ACID。
    虽然JTA事务是Java提供的可用于分布式事务的一套API，但是不同的J2EE平台的实现都不一样，并且都不是很方便使用，所以，
    一般在项目中不太使用这种较为负责的API。
    现在业内比较常用的分布式事务解决方案主要有异步消息确保型、TCC、最大努力通知

* 2PC ：两阶段提交协议  phase  commit
* TCC

分布式事务不可能100%解决，只可能尽量提高可用性，大大提高成功的概率。
#### 事务管理器（中间协调者）
* 第一阶段：预提交。先执行SQL，不提交，将结果提交给事务管理器。
* 第二阶段：commit操作/rollback操作。如果都没有问题，则通知所有的库提交事务。（可以加重试机制）
程序保证不了的，会有人工解决。


### atomikos  
* 开源框架，解决夸库的事务问题，一线互联网公司用的很少
* 跨多个库、多张表、锁粒度非常大，性能很差

### TCC(Try-Confirm-Cancel)
两阶段补偿性方案，整个系统的并发性高。
先通过try接口将资源修改成中间状态
* 阶段1：预留资源（try）：中间状态：更新中、冻结库存、草稿状态出库单
* 阶段2：确认资源（confirm/cancel）
* 重试机制、接口的幂等性、记录事务日志

#### TCC与2PC(两阶段提交)协议的区别
TCC位于业务服务层而不是资源层，TCC没有单独准备阶段，Try操作兼备资源操作与准备的能力，
TCC中Try操作可以灵活的选择业务资源，锁定粒度。TCC的开发成本比2PC高。实际上TCC也属于两阶段操作，但是TCC不等同于2PC操作。


#### 每个系统开发三个接口
* try API  
* confirm API  
* cancel API

如果你要玩儿 TCC 分布式事务，必须引入一款 TCC 分布式事务框架
你原本的一个接口，要改造为 3 个逻辑，Try-Confirm-Cancel：

* 先是服务调用链路依次执行 Try 逻辑。
* 如果都正常的话，TCC 分布式事务框架推进执行 Confirm 逻辑，完成整个事务。
* 如果某个服务的 Try 逻辑有问题，TCC 分布式事务框架感知到之后就会推进执行各个服务的 Cancel 逻辑，撤销之前执行的各种操作。

### 可靠消息最终一致性方案
* 解决异步调用的分布式事务

### 分布式事务框架
* ByteTCC （推荐）
* Himly
* TCC-transaction （推荐）





### 柔性事务解决方案架构
在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。柔性事务有两个特性：基本可用和柔性状态。
所谓基本可用是指分布式系统出现故障的时候允许损失一部分的可用性。柔性状态是指允许系统存在中间状态，这个中间状态不会影响
系统整体的可用性，比如数据库读写分离的主从同步延迟等。柔性事务的一致性指的是最终一致性。
（一）、基于可靠消息的最终一致性方案概述





### BASE理论
BA指的是基本业务可用性，支持分区失败，S表示柔性状态，也就是允许短时间内不同步，E表示最终一致性，数据最终是一致的，
但是实时是不一致的。原子性和持久性必须从根本上保障，为了可用性、性能和服务降级的需要，只有降低一致性和隔离性的要求。


### CAP定理
CAP定理，包括以下几个方面：

* 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。比如说，在购票流程处理的过程中，如果用户看到自己的
余额以及被扣了，那么它应该也能看到票夹里的票、以及支付完成的订单。
* 可用性（A）：可用性是指系统提供的服务必须一直处于可用的状态，包括每个请求都应该在一定的时间内返回结果。它包括时间和
结果两个条件，也就是说，即使出现错误、超时等问题，也应该是一定的时间内给用户反馈。
* 分区容错性（P）：如果集群系统中有一部分服务发生故障，仍然能够保证对外提供满足一致性和可用性的服务。也就是说，集群中
一部分节点故障后，集群整体还是能响应客户端的读写请求。

由于分布式系统形式的多样性和复杂性，如果想完全满足上述的原则设计一个分布式系统，几乎是不可能的。首先，分布式服系统就是
要把系统的各个部分部署到不同的服务器上，那我们就必须要通过分区容错来避免由于网络、机器故障等原因造成的问题。所以分区
容错性是必不可少的，否则可用性都无法保证。
对于可用性来说，如果我们要严格保证可用性，即使是在分区容错性得到保障的前提下，所有的服务都是可用的，有时候，我们也需要
通过异步的方式来处理一些业务，这就会造成数据的不一致。如已经从用户账户上扣费，但是票还没有转移完成等。

    * 强一致：当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这就像本地事务的原子性（A）和隔
    离性（I）的统一。在分布式系统中，如果一个业务处理需要多个系统都更新数据，那就要求多个系统的更新同时完成。但是，因为它们
    的不同的系统，‘同时完成‘需要服务间的协作、同步才能完成，在完成之前，用户不能看到更新后的数据，也不能看到更新前的（因为
    要强一致），所以用户只能等待。这就违背了可用性；同时，为了保证强一致性，需要做很多额外的工作，又大大增加了出错的可能性。
    所以在分布式系统中，强一致性一般都无法实现。
    * 弱一致性：系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入
    的值，也不会具体的承诺多久之后可以读到。例如上面的例子，我们有几个子系统，当订单系统生成订单，然后交由用户系统处理的时候，
    这时候用户就能够看到自己的新的订单。当票务系统处理票的转移的时候，用户能看到已经扣费，但是又看不到票夹里的票。虽然这个
    时间可能很短，但是也是存在的。
    * 最终一致性：弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。例如上面的例子中， 
    我们用异步方式处理用户的购票，先生成订单、扣费，异步处理票，返回给用户结果，这时用户看到的订单状态是正在处理，只有整个
    流程处理完了，用户才能看到订单结束，并且能看到买到的票。除了异步操作造成的一致性问题以外，还有在某一个节点发生故障的
    情况下，通过重试、取消等机制，或者人工参与，使得系统的数据也能最终达到一个一致的状态。

对于共享数据系统，最多只能同时拥有CAP其中的两个，任意两个都有其适应的场景，真是的业务系统中通常是ACID与CAP的混合体。
分布式系统中最重要的是满足业务需求，而不是追求高度抽象，绝对的系统特性。C表示一致性，也就是所有用户看到的数据是一样的。
A表示可用性，是指总能找到一个可用的数据副本。P表示分区容错性，能够容忍网络中断等故障。




### 接口的幂等性实现








 