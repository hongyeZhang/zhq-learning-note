(1) == 与 equal 的区别
==
对于8种基本数据，比较的是值；
对于非基本数据类型的变量，在一些书籍中称作为 引用类型的变量。
引用类型的变量存储的并不是 “值”本身，而是于其关联的对象在内存中的地址。


（2）数组与数组列表的区别
Array（[]）：最高效；但是其容量固定且无法动态改变；
ArrayList：容量可动态增长；但牺牲效率；


（3）内部类和静态内部类的区别
已经在demo中实现

（4）
“Java中，一个类实现了某接口，则必须实现该接口中的所有方法么？”这句话其实是不准确的，因为我们还没有考虑到抽象类。
抽象类实现某个接口，可以不实现所有接口的方法，可以由它的子类实现。而普通类即非抽象类则必须实现接口里的全部方法

（5）hashtable 与 hashmap 的区别
6 线程安全性不同
Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步
HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。具体的原因在下一篇文章中会详细进行分析。使用HashMap时就必须要自己增加同步处理，
虽然HashMap不是线程安全的，但是它的效率会比Hashtable要好很多。这样设计是合理的。在我们的日常使用当中，大部分时间是单线程操作的。
HashMap把这部分操作解放出来了。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，
但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。

（6）名词解释
域：相当于C++中的成员变量
实力域、静态域
初始化顺序
构建对象，就是用new class()语句建立一个新的类的对象。在这种情况下，类中的域是按照如下顺序进行初始化的：
赋予默认值-->（静态域、静态块）-->（实例域、实例块）-->构造器。
下面我给解释一下，假设一个域即变量int a，当建立对象时，首先赋予它一个默认值，int类型的默认值为0；
如果a为静态域并且在静态块中被赋值，那么就按照静态域和静态块在程序中出现的顺序先后执行；
如果同时还在实例块中被赋值，则再执行实例块中的赋值语句（静态域不可能再是实例域）；
最后执行构造器中的赋值语句（如果在构造器中有被赋值的话）。
如果变量a是实例域，则不会有静态域和在静态块中赋值（不能在静态块中给实例域赋值）的情况，其他同前所述。

（7）匿名初始化
双大括号初始化（double brace initialization）或者匿名内部类初始化法
//新建一个列表并赋初值A、B、C
ArrayList<String> list = new ArrayList<String>() {{
    add("A");
    add("B");
    add("C");
}};



这里以ArrayList的例子解释，首先第一层花括号定义了一个继承于ArrayList的匿名内部类 (Anonymous Inner Class)：

//定义了一个继承于ArrayList的类，它没有名字
new ArrayList<String>(){
  //在这里对这个类进行具体定义
};
第二层花括号实际上是这个匿名内部类实例初始化块 (Instance Initializer Block)（或称为非静态初始化块）：
new ArrayList<String>(){
  {
    //这里是实例初始化块，可以直接调用父类的非私有方法或访问非私有成员
  }
};
我们通过new得到这个ArrayList的子类的实例并向上转型为ArrayList的引用：
ArrayList<String> list = new ArrayList<String>() {{}};
我们得到的实际上是一个ArrayList的子类的引用，虽然这个子类相比ArrayList并没有任何功能上的改变。
可以认为这是个本身装有数据的子类（因为它的数据来自于自身的初始化），而不是取得引用后再赋值。

（8）泛型
如何创建一个Class<T>类型的实例？
就像使用非泛型代码一样，有两种方式：调用方法 Class.forName() 或者使用类常量X.class。
Class.forName() 被定义为返 回 Class<?>。另一方面，类常量 X.class 被定义为具有类型 Class<X>，
所以 String.class 是Class<String> 类型的。
