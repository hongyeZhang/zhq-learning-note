
# JVM 所有知识点整理

## 类的加载和初始化的步骤整理

### JVM中的内存区域（运行时数据区）
* 方法区： metaspace 主要存放类的一些信息
* 程序计数器：记录当前执行的字节码指令位置，即目前执行到了那条字节码指令，每个线程都会有自己的程序计数器
* java虚拟机栈：保存每个线程的执行栈帧。包括方法内的局部变量，操作数栈，方法出口等。每个线程都会有自己的虚拟机栈。
* java堆内存：对象的存放地址。 年轻代 + 老年代
* 本地方法栈

### 加载到使用主要步骤
* 加载：将编译好的.class 字节码加载到JVM内存中
* 验证：根据JVM规范，校验加载进来的.class 字节码文件
* 准备：给类和类变量分配一定的内存空间，且给类变量设置默认的初始值（0或null）
* 解析：把符号引用替换为直接引用
* 初始化：根据类初始化代码给类变量赋值（new对象的时候，如果父类没有初始化，则先初始化父类）
* 使用：
* 卸载：

### java里有哪些类加载器
* 启动类加载器：加载核心类库 lib
* 扩展类加载器：加载目录 lib/ext
* 应用程序加载器：加载classpath 指定路径的类，比如我们自己写的代码
* 自定义类加载器：按照自己的需求加载类

### 什么是双亲委派机制
* 有亲子的结构，四种加载器位于不同的层级上
* 当应用程序类需要加载一个类的时候，先委派给自己的类加载器去加载，最终传到给最顶层的类，
    如果在父类的负责加载范围内没有找到类，会交给子类去加载。


## 什么时候回触发 minorGC
* Eden + S1 的区域不足以分配新产生的对象时


## 垃圾回收算法
* 年轻代：复制算法： eden : S1 : S2 = 8:1:1
* 老年代：标记整理算法： mark + sweep


## 垃圾收集器
serial + serialOld : 单线程，stop the world，基本不采用
parNew + CMS :多线程并发控制，一般身体国产的标配
G1 : 统一收集新生代和老年代


## 问题列表
* 什么时候出发MinorGC?
    - Eden+S1 的剩余空间不足的时候
        - 1 新生代的现有存活对象小于老年代剩余内存，老年代足以支撑可能晋升的对象
        - 2 情况1不成立，但是设置了空间担保，担保可以成功时。

* 触发minorGC之前如果检查老年代大小，涉及哪几个步骤和条件？
    - 1 判断老年代的剩余空间是否大于新生代的已用大小，如果可以，则minorGC
    - 2 情况1不成立时，如果设置了空间担保，检查老年代的剩余内存是否大于每次新生代晋升的平均内存大小，if true，则 MinorGC; 如果没有设置空间担保，或者担保失败，则FullGC

* 什么时候在触发一次MinorGC 之前就会提前触发一次FullGC?
    - 新生代现有的存活对象 > 老年代的剩余内存，没有设置空间担保，或者空间担保失败。则先进行一次FullGC。再进行MinorGC

* Full GC的算法是什么？
    - 标记整理算法
    - CMS : 标记+清除+整理

* CMS垃圾处理器的工作过程
    - 初始标记：标记由4中GCRoots（方法的局部变量，类的静态变量）直接关联的对象  STW
    - 并发标记：对老年代所有的对象进行trace，看是否能与gc roots建立间接关系，判断GCRoots是否可达
    - 重新标记：标记并发阶段引用变动的对象  STW
    - 并发清理：并发清理掉可以回收的内存，但是由于用户线程依然在运行，每次FullGC都清理不干净，会产生浮动垃圾。
    - 碎片整理，可以设置多少次 FullGC 之后要进行一次内存碎片整理

* MinorGC 之后可能对应哪几种情况？
    - 如果新对象大小+存活对象 < S1，则分配在新生代；否则，放入老年代。 如果老年代空间不足，先进行FullGC，再进行MinorGC，如果剩余空间还不够，则OOM

* 哪些情况MinorGC之后的对象会直接进入老年代？
    - 新生代放不下(S1 < 存活对象的占用空间)，老年代可用区域 > 存活对象的占用空间
    - 达到进入老年代的年龄 MaxTenuringThreshold

* 触发FullGC的时机
    - 老年代的可用内存小于新生代全部对象的大小，没有开启空间担保，则FullGC
    - 空间担保失败，提前FullGC
    - 新生代代minorGC之后的存活对象大于S1，直接进入老年代，而此时老年代空间不足
    - 如果是CMS收集器，如果老年代的使用空间大于指定的比例（默认92%），则也会触发FullGC
 
* 任何保证只做YongGC，JVM如何配置？
    - 避免对象进入老年代
        - 保证minorGC之后的存活对象大小 < S1，根据实际情况查看每次minGC之后存活对象的大小，合理设置S1的大小
        - 合理控制对象在新生代的生存年龄，可以降低15岁至5岁，让该进入老年代的对象尽快进入老年代，不要在新生代继续占据空间。
        - 合理设置大对象的大小，如果创建销毁频繁，让其直接进入老年代；如果偶尔创建，则在新生代即可。
        - 尽可能保证每次minorGC之后的存活对象的大小 < survivor的50%

* 为什么老年代不采用复制算法回收？
    - 因为老年代存活对象太多，采用复制算法来回移动大量的对象，效率会更低；而新生代的对象生命时间短，大部分对象会直接消亡

* 为什么CMS回收器老年代垃圾回收慢？
    - 剩余的存活对象很多，可能达到90%，不得不标记整理，不能复制；
    - 并发标记阶段，对老年代的所有对象GCRoots追踪比较慢，比较耗时；从GCRoots查找，直接或者间接引用的对象就标记为活的，剩下的就是垃圾。
      而新生代的90%以上不会再存活，所以新生代的GC快
    - 垃圾回收完，还会STW，进行内存碎片的整理

* 那些对象可以作为GCRoots？
    - 虚拟机栈（栈帧中的本地变量表）中引用的对象（局部变量）
    - 方法区中的静态变量
    - 常量引用的对象
    - 本地方法栈中JNI（一般所说的native方法）引用的对象

* minorGC FullGC 都会STW吗？
    - 是的，但是新生代很快，就是从GCRoots出发标记出来少量的存活对象，转移到Survivor中，然后直接清空所有的垃圾对象

* 新创建的对象放在eden还是survivor?
    - 只放在eden，survivor只放存活的对象

* 对象进入老年代的情况是什么？
    - 年龄大了
    - 动态年龄判断
    - 新生代GC后存活的对象不足以放到 survivor 中

* 介绍一下G1收集器？
    - 是以垃圾回收优先的收集器，将内存区域划分为多个 region，然后维护一个回收价值列表，建立一个可预测的时间停顿模型
      内部保留了分代，但是是逻辑上的保留，新生代和老年代会根据需要进行变化。

* G1垃圾回收器比 ParNew + CMS 进步在哪里？
    - 使STW的时间变得可控，特别适合大内存的应用，如16G 32G，因为如果使用普通的CMS方式，会造成FullGC的时间特别长，系统停顿时间特别长
    - region使用复制算法，不会产生内存碎片

* 使用G1收集器，值得优化的地方？
    - 新生代优化策略
        - 预估每次GC后的存活对象，确保survivor能够放下
        - 避免高峰期间，新生代对象满足年龄判断条件，导致短期存活对象进入老年代
        - 大对象有大对象的region，不占用老年代，基本不用考虑 
    - 老年代优化策略
        - 预期停顿时间合理设置，太小容易造成回收频繁，影响系统的吞吐量，太大增大系统的停顿时间。影响用户的体验。
          不是越小越好，如果过小，则可能多次回收没有效果，导致回收失败FullGC,serialOld 单线程STW，造成系统停顿
        - G1HeapWastePercent 默认5%，可以适当提高，
        - MixedTGCLiveThresholdPercent 参数先保持默认
          
* 什么时候可能会导致G1频繁的触发Mixed混合垃圾回收？
    -InitiatingHeapOccupancyPercent设置的值太小

* 垃圾收集器的设置？
    - 对于CPU性能高的、内存大的，对系统的响应度要求高的系统推荐使用G1
    - CPU 性能低的、内存小的，ParNew + CMS 比较合适

* 一个系统中长生命周期的对象包括哪些？
    - spring 的 bean
    - 线程池的核心线程、连接池等
    - tomcat的各类组件：connector container filter server listener 
    - classLoader Class对象
    
* 系统如何尽量减少FULL GC？ 
    - 首先说明什么情况下发生 full gc：
        - 1、Minor GC 前：
        - 年轻代对象大小 > 老年代可用内存&&没开通内存分配担保情况 
        - 年轻代对象大小 > 老年代可用内存&&开通内存分配担保情况下，历次年轻代GC进入老年代大小平均值>老年代可用内存大小 
        - 2、Minor GC 后，老年代放不下GC后存活的对象 
    - 二、为了避免full gc：
        - 使每次minor gc后，存活的对象尽量能放在s区，不要放到老年代： 
        - 可以调大survivor区的大小。考虑到动态年龄判断，如果系统资源比较足，可以估算每次minor gc后，存活对象的大概大小，
        将survivor区内存设置为这个内存的一倍。如果系统运算时间比较长，导致对象的年龄比较大，可以适当调大"-XX:MaxTenuringThreshold
        "，使对象年龄大一些再进入老年代，这样也可以减少进入老年代的对象
        
* CPU负载过高的原因？
    - 系统中启动了大量的线程，满负荷工作
    - FullGC 频繁，占用CPU资源

* 频繁FullGC的原因？
    - 系统突然承载高并发请求，处理的数据量过大，导致YoungGC频繁，每次YoungGC之后存放的对象过多
      内存分配不合理，survivor空间不够，导致对象频繁进入老年代，频繁触发FullGC
    - 系统一次性加载过多的数据到内存，产生很多大对象，频繁进入老年代
    - 系统发生了内存泄露，大量对象一直占在老年代里，频繁FullGC 回收不了
    - metaspace （永久代）加载类过多频繁发生FullGC
    - System.gc()

* 排查方案
    - jstat -gc 分析GC频率  
    - MAT分析大对象和内存泄露

* 可能发生内存溢出的区域？
    - metaspace 推荐 512M 方法区，如果类太多会溢出
        - 默认参数太小时，容易溢出
        - cglib等动态生成了太多类，需要避免
    - 虚拟机栈，默认1M Xss
    - 堆内存

* 服务假死的原因？
    - 系统使用了大量的内存，导致频繁FullGC
    - CPU负载太高，应用程序无法得到CPU资源去响应接口的调用请求

* WeakReference
    - 缓存中用的比较多，如果内存不足，会被回收掉