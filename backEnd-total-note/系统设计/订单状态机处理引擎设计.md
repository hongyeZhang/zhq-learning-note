
# 通用的状态机引擎及其编排

## 参考文章
* https://zhuanlan.zhihu.com/p/368197897 高德打车通用可编排订单状态机引擎设计


## 参数传递
* 一般要将数据在多个方法中进行传递有两种方案：
    * 一个是包装使用ThreadLocal、每个方法都可以对当前ThreadLocal进行赋值和取值；
    * 另一种是使用一个上下文Context对象做为每个方法的入参传递。
    * 这种方案都有一些优缺点，使用ThreadLocal其实是一种"隐式调用"，虽然可以在"随处"进行调用、但是对使用方其实不明显的、在中间件中会大量使用、在开发业务代码中是需要尽量避免的；
    * 而使用Context做为参数在方法中进行传递、可以有效的减少"不可知"的问题。
    * 不管是使用ThreadLocal还是Context做为参数传递，对于实际承载的数据载体有两种方案，常见的是使用Map做为载体，业务在使用的时候可以根据需要随意的设置任何kv，但是这种情况对代码的可维护性和可读性是极大的挑战，所以这里使用泛型类来固定数据格式，一个具体的状态处理流程到底需要对哪些数据做传递需要明确定义好。其实原则是一样的，业务开发尽量用用可见性避免不可知。

## 状态消息
一般来说，所有的状态迁移都应该发出对应的消息，由下游消费方订阅进行相应的业务处理。
（1）状态消息内容
对于状态迁移消息的发送内容通常有两种形式，一个是只发状态发生迁移这个通知、举例子就是只发送"订单ID、变更前状态、变更后状态"等几个关键字段，具体下游业务需要哪些具体内容在调用相应的接口进行反查；还有一种是发送所有字段出去、类似于发一个状态变更后的订单内容快照，下游接到消息后几乎不需要在调用接口进行反查。
（2）状态消息的时序
状态迁移是有时序的，因此很多下游依赖方也需要判断消息的顺序。一种实现方案是使用顺序消息（rocketmq、kafka等），但基于并发吞吐量的考虑很少采用这种方案；一般都是在消息体中加入"消息发送时间"或者"状态变更时间"字段，有消费方自己进行处理。


（3）数据库状态变更和消息的一致性
状态变更需要和消息保持一致吗？
很多时候是需要的，如果数据库状态变更成功了、但是状态消息没有发送出去、则会导致一些下游依赖方处理逻辑的缺失。而我们知道，数据库和消息系统是无法保证100%一致的，我们要保证的是主要数据库状态变更了、消息就要尽量接近100%的发送成功。
那么怎么保证呢？

其实通常确实有几种方案：
a）使用rocketmq等支持的两阶段式消息提交方式：
先向消息服务器发送一条预处理消息
当本地数据库变更提交之后、再向消息服务器发送一条确认发送的消息
如果本地数据库变更失败、则向消息服务器发送一条取消发送的消息
如果长时间没有向消息服务器发生确认发送的消息，消息系统则会回调一个提前约定的接口、来查看本地业务是否成功，以此决定是否真正发生消息
image.png

b）使用数据库事务方案保证：

创建一个消息发送表，将要发送的消息插入到该表中，同本地业务在一个数据库事务中进行提交
之后在由一个定时任务来轮询发送、直到发送成功后在删除当前表记录
c）还是使用数据库事务方案保证：

创建一个消息发送表，将要发送的消息插入到该表中，同本地业务在一个数据库事务中进行提交
向消息服务器发送消息
发送成功则删除掉当前表记录
对于没有发送成功的消息（也就是表里面没有被删除的记录），再由定时任务来轮询发送
image.png

还有其他方案吗？有的。

d）数据对账、发现不一致时进行补偿处理、以此保证数据的最终一致。其实不管使用哪种方案来保证数据库状态变更和消息的一致，数据对账的方案都是"必须"要有的一种兜底方案。


## 思考问题
1 状态流转并发问题怎么处理？
如果一个订单当前是状态A、此刻从不同的维度或入口分别发起了不同的事件请求，此时怎么处理？
比如当前订单是新创建完成状态，用户发起了取消同时客服也发起了取消，在或者订单是待支付状态、系统发起了免密支付同时客服或者用户发起了改价。这些场景不管是系统照成的并发还是业务操作造成的并发，并发是真实存在的。对于这种情况、原则是同一时刻一个订单只能有一个状态变更事件可进行，其他的请求要么排队、要么返回由上游进行处理或重试等。

我们的做法是：
在状态机OrderFsmEngine的sendEvent入口处，针对同一个订单维度加锁（redis分布式锁）、同一时间只允许有一个状态变更操作进行，其他请求则进行排队等待。
在数据库层对当前state做校验、类似与乐观锁方式。最终是将其他请求抛错、由上游业务进行处理。

2 能不能动态实现状态流程的切换和编排？
* 状态流转事十分核心的业务、一般不需要修改，一旦因变更导致故障是不可想象的。