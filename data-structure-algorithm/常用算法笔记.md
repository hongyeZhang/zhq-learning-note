
# 《基本算法总结》
* 总结各种算法的思路及重要要素，以 leetcode 上面的题目作为相关的例题练习

## chapter0-概述
### 0-1笔记参考资料
* labuladong 的算法小抄

### 0-2常用算法概述
* 递归
    * 递归的实质就是借用栈实现一些操作，利用递归能够实现的操作使用栈也能实现，并且直接利用栈的话可以很好的控制停止，效率更高（通常使用迭代法）。这主要是因为递归是一个有“来回”过程，回来的时候需要特殊判断（结束条件）。
    * 为什么会使用递归：递归思路对程序员来说更加简洁巧妙，并且递归的思考方式更偏向于人的思考方式。在解决一些可以将父问题通过一定的关系转化为相同子问题的复杂问题时，使用递归思想能够简洁巧妙的解决。
* 回溯法
    * 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：找到一个可能存在的正确的答案；在尝试了所有可能的分步方法后宣告该问题没有答案。
    * 回溯法的核心为试探和复原。整个过程利用递归去执行，在递归函数执行前取修改尝试，满足条件后下沉到下一层，试探完成后将数值复原。在整个试探和复原的过程中找到最终需要的一个或所有解。
* 深度优先遍历
    * 是一种用于遍历或搜索树或图的算法。这个算法会尽可能深的搜索树的分支。当结点v的所在边都己被探寻过，搜索将回溯到发现结点v的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。


## chapter1-数组
### 概述
* 主要的算法技巧就是双指针，双指针又分为中间到两端扩散、两端到中间收缩的双指针、快慢指针。
* 前缀数组
* 查分数组
* 滑动窗口

### 知识点详述
* 0-基本问题
    * 穷举一个数组有多少个子数组（遍历数组的所有子集）
        * 总共有 Math.pow(2,n)个子数组，Cn0+Cn1+Cn2+Cn3+...+Cnn = 2^n
    * 集合的全排列问题（对于给定的集合A{a1,a2,…,an},其中的n个元素互不相同，如何输出这n个元素的所有排列）
        * 一个n大小的集合有 n! 个全排列组合。第一个位置有 n 种选择，第二个位置有 n-1 种选择 ... 最后一个位置有 1 种选择
            * 时间复杂度：每个内部结点循环N次，故非叶子结点的时间复杂度为 O(N×N!)；叶节点共N!个，在叶子结点处拷贝需要 O(N)，叶子结点的时间复杂度也为 O(N×N!)。因此，时间复杂度为O(N×N!)。
            * 空间复杂度：全排列个数 N!，每个全排列占空间 N。空间复杂度为O(N×N!)。
        * 数字全排列问题：给定一个数字n，求出所有1∼n的一个全排列。
        * 
* 01-数组的基本操作
    * 删除操作数组元素：在尾部删除、插入元素比较高效O(1)，但是在中间或者开头插入元素，会涉及到数据的迁移，时间复杂度O(n) 
    * 
    * 例子：T26 T83 T27 T283
* 1-数组前缀和
    * 主要适用场景：原始数组不会被修改的情况下，频繁查询某个区间的累积和。
    * 以空间换时间，其实就是通过预先计算出前面一些元素的和，存到数组中，然后在计算时直接给出结果的方式，避免了每次都计算的操作，时间复杂度由 O(N) 变为 O(1)
    * 例子：T303-区域和检索  T304-矩阵区域的检索 T560-和为K的子数组
* 2-差分数组
    * 主要适应场景：频繁对原始数组的某个区间元素进行增减
    * 例子： T1094-拼车问题 T1109-航班预定统计 T370-区间加法
* 3-滑动窗口
    * 基本算法模板，常见的时间复杂度为 O(N)，主要需要注意的点是一些细节问题，什么时候需要扩大窗口，什么时候需要缩小窗口，什么时候更新结果。
    * 确定窗口的区间，可以保持左闭右开 [left, right)。编码中要时刻注意窗口的定义，左闭右开
        ```java
        int left = 0, right = 0;
        while(right < s.size()) {
            window.add(s[right]);
            right++;
            doSomething();// 窗口右移，进行窗口内数据的一些列更新
            while(window need shrink) {
                window.remove(s[left]);
                left++;
                doSomething();// 窗口左移，进行窗口内数据的一些列更新
            }
        }
        ```
    * 例子： T76 T567 T438 T438 T3 在一个字符串中查找符合条件的另一个字符串

* 4-二分查找
    * 前提：待搜索的数组是一个已经排好序的有序数组
    * 特点：思路很简单，但是需要处理众多的细节问题。比如 < 还是 <= 号的使用。
    * 常用场景：寻找一个数、寻找左侧边界、寻找右侧边界。时间复杂度 O(logn)
    * 二分搜索问题的泛化：f(x)是x定义域上的单调函数，题目需要计算 f(x)==target 的值
    * 二分查找算法伪代码
        ```java
        int binarySearch(int[] nums, int target) {
            int left = 0, right = ...;
            while(...) {
                int mid = left + (right-left)/2 // 使用 right -left 可以避免数值太大溢出
                if(mid == target) {
                    ...
                } else if (nums[mid] < target) {
                    left = ...
                } else if (nums[mid] > target) {
                    right = ...
                }
            }
            return ...
        }
        ```
    * 寻找左侧边界, [left, right] 闭区间搜索，返回的是 left 
    ```java
        int leftBound(int[] nums, int target) {
            int left = 0, right = nums.length - 1;
            while(left<=right) {
                int mid = left + (right-left)/2
                if(mid == target) {
                    right = mid - 1;
                } else if (nums[mid] < target) {
                    left = mid + 1;
                } else if (nums[mid] > target) {
                    right = mid - 1;
                }
            }
            // 检查出界情况
            while(left >= nums.length || nums[left] != target) {
                return -1;
            }
            return left;
        }
    ```
    * 寻找右侧边界，[left, right] 闭区间搜索，返回的是 right
    ```java
        int rightBound(int[] nums, int target) {
            int left = 0, right = nums.length - 1;
            while(left<=right) {
                int mid = left + (right-left)/2;
                if(mid == target) {
                    left = mid + 1;
                } else if (nums[mid] < target) {
                    left = mid + 1;
                } else if (nums[mid] > target) {
                    right = mid - 1;
                }
            }
            while(right < 0 || nums[right] != target) {
                return -1;
            }
            return right;
        }
    ```
    * 例子 T704-二分查找、查找左边界、查找右边界 T-875吃香蕉 T-1011送达包裹 剑指offer11-旋转数组中的最小数字
* 5-双指针
    * 应用场景
        * 数组的原地修改问题
        * 两数之和：（1）暴力求解 （2）HashMap存储 （3）对撞指针
        * 三数之和：（1）HashMap 存储，然后再遍历 O(n^2) （2）先给数组进行排序，再固定一个值做循环，然后两面两个值做双指针的对撞，根据结果移动指针
        * 四数之和： 使用四个指针(a<b<c<d)。固定最小的a和b在左边，c=b+1,d=_size-1 移动两个指针包夹求解。
                    保存使得nums[a]+nums[b]+nums[c]+nums[d]==target的解。偏大时d左移，偏小时c右移。c和d相
                    遇时，表示以当前的a和b为最小值的解已经全部求得。b++,进入下一轮循环b循环，当b循环结束后。
                    a++，进入下一轮a循环。 即(a在最外层循环，里面嵌套b循环，再嵌套双指针c,d包夹求解)。
    * 例子：T870-田忌赛马求优势项目个数 T27-移除元素 T283-移动零

* x-其他
    * 合并k个排序数组（将k个已经排序好的数组合归并成一个有序的数组）
        - (1) 放入到一个大数组中进行快速排序 O(N*logN)
        - (2) 通过堆排序实现 O(N*logK), 构建一个K大小的小顶堆，每次取出堆顶元素，将其放入新数组的位置中。 PriorityQueue


## chapter2-链表

### 1-基本算法
#### 1-1 floyd判环(圈)算法
* 如何检测一个链表是否有环，如果有，那么如何确定环的起点？如何确定环的长度？
  * 时间复杂度：O(n) 空间复杂度：O(1)
  * 算法：
        1. 一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果是等价的，只要一个比另一个快就行）。 如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾，那么说明没环。
        2. 环的长度: 慢指针与快指针第一次相遇后，继续前进，直到快慢指针相遇，经过的路径就是环的长度。
        3. 环的起点：将慢指针（或快指针）移到链表起点，两者同时移动，每次移动一步，那么两者相遇的地方就是环的起点。

### 2-详述

* 例子  T21 T23 T141 T142 T876 T19 T160 

* 单链表的相关操作
    * 技巧：通常会有一个虚拟头节点的节点，就是 dummy 节点，占位符可以避免空指针的情况，降低代码的复杂性。


* 1-删除链表节点
    * [**删除指定的节点**] 注意判断传入的链表头节点，删除的节点是不是头结点和尾节点
    * [**删除倒数第K个结点**] 快慢指针方法，fast、slow、preSlow，preSlow.next = slow.next.next 注意判断链表长度小于 k 和删除的节点是头结点的情况
* 2-单向链表反转
    * [**整个链表全部反转**] 
        * pre、current、next 三个辅助节点，注意判断链表的长度，处理边界情况 T206
        * 利用递归算法进行翻转 
    * [**单向链表仅反转从m到n的部分链表**] 四个关键的标志点，m之前、m、n、n之后，其余的按照反转链表来做即可
* 3-链表旋转
    * [**链表向右旋转k个位置**] 找到分界点，first、second 标记，注意链表长度小于 k 的情况
* 4-链表中环的操作
    * [**检测链表中是否有环**] 快慢指针法。设置快慢指针，快指针每次走两步，慢指针一次走一步。假如有环，他们最后一定相遇在环中
    * [**找到链表中环的入口**] Floyd 判定方法。(1)判断是否有环 (2)两个指针相遇后，让两个指针分别从链表头和相遇点重新出发，每次走一步，最后一定相遇于环入口。 这里直接写结论，证明STFW
* 5-链表合并
    * [**合并两个有序的链表**] 拉链法，直接根据节点的大小值进行合并就行  T21
    * [**合并K个有序的链表**]  利用大小为K的小顶堆(PriorityQueue)，然后从堆顶取出元素，放在结果链表的节点后面即可 T23
* 6 求链表的指定节点
    * [**求链表的中间节点**] 快、慢指针，直接返回 slow 即可
    * [**求链表的倒数第K个节点**] 两个指针，一个P1先走K步，另一个P2再开始，待到P1走到最后，返回P2即可。 剑指Offer-22-链表中倒数第k个节点
    * [**求链表的相交节点**] p1遍历完列表A后再遍历链表B，p2遍历完列表B后再遍历列表A，相当于在逻辑上将两个链表连接在一起，使得p1 p2同时进入公共部分，返回公共节点C1
    * [**判断两个链表是否相交**] 如果两个链表相交于某一节点，那么之后的节点都是共有的，分别遍历两个链表到尾节点，判断两个尾结点是否相等即可
    * [**链表相交扩展——求两个无环单链表的第一个相交点**]
        * (1) 分别反转两个链表，再从头遍历，找到两个链表第一个不相等的节点的上一个节点
        * (2) 辅助数据结构（栈），两个链表分别入栈，再从两个栈顶开始分别遍历，找到最后一个相同的节点
* 7-链表排序
    * [**快速排序**] 与数组的快速排序类似
    * [**归并排序**] 与数组的归并排序类似（再理解一下）
    * [**衍生题目**] 归并两个有序链表

* 7 链表划分（给定一个单链表和数值x，划分链表使得所有小于x的节点排在大于等于x的节点之前）
    - 针对大于x和小于x的部分分别创建单链表，利用 leftDummy rightDummy 辅助节点
    - 合并以上两部分
* 8 链表求和 （写出一个函数将两个整数相加，用链表形式返回和）
    - 顺序遍历两个链表，直接将对应的元素相加即可，注意进位的处理 carry
    - 可借助 dummyNode/sentinelNode 实现


## chapter3-基本数据结构操作
* 1-队列
    * [**用栈实现队列**] 通过两个栈 s1(操作队尾) s2(操作队列头)，实现队列的 push pop peek isEmpty 等方法。T232

* 2-栈
    * [**用队列实现栈**] 通过两个队列 queue1 queue2 实现一个栈的功能，queue1 存储队列的元素，queue2 作为辅助的操作队列 T225
    * [**判断有效的括号**] 利用栈对左右两边的括号进行抵消，判断栈最终剩下的容量是否为空。引申判断最小需要插入的个数等  T20 T921 T1541
    * [**单调栈**] 计算一个数组中每个元素右边的第一个更大的值，一但要求下一个更大的元素，就是用单调栈解。T496 T503
        * 单调栈的算法模板如下： 
            ```java
                public int[] nextGreaterElement(int[] nums) {
                    Stack<Integer> stack = new Stack<>();
                    int[] res = new int[nums.length];
                    for (int i = nums.length - 1; i >= 0; --i) {
                        while (!stack.isEmpty() && stack.peek() <= nums[i]) {
                            stack.pop();
                        }
                        res[i] = stack.isEmpty() ? -1 : stack.peek();
                        stack.push(nums[i]);
                    }
                    return res;
                }
            ```








## 查找
* 顺序(线性)查找
* 二分查找/折半查找
* 哈希表查找
* 二叉排序树查找







## 字符串

### 字符串匹配
* 暴力匹配
    - 时间复杂度 O(m*n)
* KMP
    - 时间复杂度 O(m+n)
    - 寻找前缀后缀最长公共元素的长度
    - 重点是next数组的求法，next数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。
* BM
    - TODO
* Sunday
    - TODO

### 字符串其他算法
* 1 替换字符串中的空格
    - 将字符串中的每一个字符按部就班的处理即可
* 2 字符串数组的最长公共前缀
    - 将字符串数组按照字典顺序排序，然后取第一个和最后一个字符串，求这两个字符串的最长公共前缀即可
* 3 最长回文串
    - 具体要求：给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串
    - 解题思路：统计字母出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。
* 4 验证一个字符串是否是回文串
    - 双指针对撞进行验证即可
* 5 找出一个字符串中的最长回文子串
    - 以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。
* 6 最长回文子序列（注意与子串的区别）
    - 动态规划，注意状态转移公式
* 7 字符串的排列（写一个函数来判断 s2 是否包含 s1 的排列）
    - 滑动窗口：不用真的去算出s1的全排列，只要统计字符出现的次数即可。可以使用一个 哈希表/数组 配上双指针来做。
* 8 字符串中第一个只出现一次的字符
    - 遍历两边字符串，第一次先统计每个字符的出现次数，存入哈希表；第二遍判断第一次出现的字母即可。
* 9 单词反转
    - 将单词 根据 " +"正则表达式进行分割，然后逆序组装。
* 10 旋转字符串
    - 在第 n 个字符后面将切一刀，将字符串分为两部分，再重新并接起来即可。
    - 注意字符串长度为 0 的情况。
* 11 判断字符串A旋转多次之后能否变成字符串B
    - return A.length() == B.length() && (A+A).contains(B);
* 12 字符串转化为整数
    - 每个字符拆解之后相加
    - 注意 int 大小溢出的情况
        - 通过 long 来解决
        - 通过 比较与 MAX_INTEGER / 10  MAX_INTEGER % 10 的大小来提前判断是否溢出 
* 13 字符串 正则表达式匹配
    - 动态规划，比较难 
    - TODO
* 14 无重复字符的最长子串
    - 动态规划，
    - 维护一个到目前位置 i 的最长的不重复子串的列表长度
* 15 字符串全排列
    - 回溯+递归
    



## 树
### 二叉树
* 1 求二叉树所有节点的个数
    - 1 + 左子树个数 + 右子树个数
    - if node == null -> return 0
* 2 求二叉树的最大深度（即求根节点的深度）
    - 1 + max(左子树最大深度 + 右子树最大深度)
    - if node == null -> return 0
* 3 二叉树的最小深度
    - 注意与最大深度区分，一定是从子节点开始计算深度，不能直接计算 min
    - (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;
* 4 二叉树的所有路径
    - 递归调用，当到达叶子节点时，将此时的路径添加到结果集中即可
* 5 判断是否为AVL树
    - 分别求出左、右子树的深度，
    - if abs(maxDepth(node.left) - maxDepth(node.right)) > 1 -> return false
    - else return 子树的递归调用
* 6 二叉树遍历（先序）
    - 辅助栈
* 7 二叉树遍历（中序）
    - 辅助栈
* 8 二叉树遍历（后序）
    - 辅助栈，注意记录遍历的次数，第二次遍历时再输出
* 9 二叉树遍历（层序）
    - 辅助结构：双端队列
* 10 从上到下分层打印二叉树
    - 在层序遍历的从基础上，记录每一层的节点个数，打印完指定数目的节点后，再打印下一层
* 11 从下到上分层打印二叉树
    - 与从上到下打印的步骤基本一致
    - 借助一个辅助的数据结构，将每一行的打印结果逆序添加到输出队列里
* 12 之字型层序遍历
    - (a) 与11题步骤一致，最后将结果数组的偶数部分逆序即可
    - (b) 通过两个辅助栈和一个添加的标志位，不同的打印顺序添加到不同的栈里面
* 13 求二叉树第K层的节点个数
    - (a) 层次遍历，遍历完 k-1 层（即此时第k层的所有节点已经入队），求此时队列的 size 即可
    - (b) 递归：一个节点的第K层的节点个数 = 左节点的第k-1层节点个数 + 右节点的第k-1层节点个数
* 14 求二叉树第K层的叶子节点个数
    - (a) 层次遍历，遍历完 k-1 层（即此时第k层的所有节点已经入队），判断此时队列中叶子节点的个数
    - (b) 与 13 的递归思路一致，但在递归的终止条件中需要判断是否是叶子节点，if leaf -> return 1; else -> return 0
* 15 判断两棵二叉树是否结构相同
    - 递归判断
        - 如果两棵二叉树都为空，返回真
        - 如果两棵二叉树一棵为空，另一棵不为空，返回假
        - 如果两棵二叉树都不为空，且节点值相同。如果对应的左子树和右子树都同构则返回真，其他返回假
* 16 求二叉树的镜像
    - 左右子树分别交换即可
* 17 判断二叉树是否镜像对称
    - isSymmetricCore(left.right, right.left) && isSymmetricCore(left.left, right.right);
    - 注意边界条件：两个节点是够为空，两个节点的值是否相等
* 18 求普通二叉树中两个节点的最低公共祖先节点
    - 如果两个节点分别在根节点的左子树和右子树，则返回根节点
    - 如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树
    - TODO 再看一下
* 19 求二叉搜索树的最低公共祖先：（性质：左子树 < 根节点 < 右子树）
    - 利用二叉搜索树的性质：
        - 如果根节点的值均小于两个节点，则递归右子树寻找
        - 如果根节点的值均大于两个节点，则递归左子树寻找
        - 如果值在二者之间，则返回根节点
* 20 求二叉树的直径 （一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。）
    - TODO
    - 左子树的深度 + 右子树的深度 + 1
* 21 由前序遍历序列和中序遍历序列重建二叉树
    - 根据前序和中序的性质进行递归求解即可
    - 
* 22 由后序遍历序列和中序遍历序列重建二叉树
    - 方法与 21 一致
    - 根据前序和后序遍历无法构造出唯一的二叉树
* 23 判断二叉树是不是完全二叉树
    - 完全二叉树是指最后一层左边是满的，右边可能慢也不能不满，然后其余层都是满的，根据这个特性，利用层遍历
    - 如果我们当前遍历到了NULL结点，如果后续还有非NULL结点，说明是非完全二叉树
* 24 树的子结构B是否是A的子树
    - 先找到尽所有可能开始的根节点,然后从该根节点开始找是不是子树，如果是直接结束，不是就看A的子树其他的节点
* 25 二叉树中和为某一值的路径
    - 暴力求解：找到二叉树中的所有路径，然后判断路径和是否符合要求
    - 回溯法：通过一个栈来维护路径上经过的节点，回到上一层时，需要将本层的节点弹出
* 26 二叉搜索树的第k个结点
    - 二叉搜索树按照中序遍历的顺序打印出来就是排好序的，按照中序遍历找到第 k 个结点就是所求的节点
* 27 寻找二叉树（每个节点包含父节点的指针）中序遍历的后继节点
    - 分三种情况进行讨论
        - 如果节点有右子树，则该节点是右子树最左的孩子节点
        - 没有右子树，且是父节点的左孩子，则父节点就是所求节点
        - 没有右子树，且是父节点的右孩子，则往上寻找，找到一个祖先节点A，是其父节点B的左孩子，B是所求节点




## 常用算法
* 动态规划
* 分治法
* 贪心求解法
* 回朔法
     - 面试题12 矩阵中的路径


* 分支限界法




### 十大排序算法
* 非线性比较类排序：非线性是指算法的时间复杂度不能突破(nlogn)，元素之间通过比较大小来决定先后顺序。
    - 交换排序
        - 冒泡排序
        - 快速排序
    - 插入排序
        - 简单插入排序
        - 希尔排序
    - 选择排序
        - 简单选择排序
        - 堆排序
    - 归并排序
        - 二路归并排序
        - 多路归并排序
* 线性非比较类排序：算法的时间复杂度能够突破(nlogn)，并且不通过比较来对元素排序。
    - 计数排序
    - 基数排序
    - 桶排序


### 动态规划
* 三个重要元素：最优子结构、边界、状态转移公式
* 特性：最优子结构、重叠子问题

* 1 最大子序和 （leetcode 53） 
    - 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
* 2 青蛙跳台阶问题
    - 本质是斐波那契数列问题
    - 直接动态规划求解即可
    
    
    
### 图
* 岛屿问题
* 并查集
    - 无向图的连通分量






## 典型题目 
 
* 1-1 最长公共子序列 (LCS)
    - 动态规划：
        - dp[i][j] 表示以 A[i] B[j] 为结尾的计算最长公共子序列的长度， dp[lenA-1][lenB-1] 即为最长公共子串的长度
        - if str1Arr[i] == str2Arr[j] ->  dp[i][j] = dp[i - 1][j - 1] + 1
        - else  dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
    - 输出最长公共子序列：
        - 根据 dp 矩阵，从右下角开始回溯，找到所有的子序列。
* 1-2 最长公共子串 
    - 动态规划： 
        - if str1Arr[i] == str2Arr[j] -> dp[i][j] = dp[i - 1][j - 1] + 1  

* 2-1 最长递增子序列 (LIS) 
    - 不一定连续，但是顺序不能乱
    - 动态规划：
        - L(j)={ max(L(i))+1, i<j且a[i]<a[j] }。
        - 遍历在j之前的所有位置i(从0到j-1)，找出满足条件a[i]<a[j]的L(i)，求出max(L(i))+1即为L(j)的值。
        - 遍历所有的L(j)（从0到N-1），找出最大值即为最大递增子序列。时间复杂度为O(N^2)。
    - 转化为最长公共子序列的方法
        - 将原序列 A 进行排序获得序列 A'，再求两个序列的最长公共子序列
* 2-2 最长连续递增子序列
    - 一定要连续
    - 动态规划：
        - 初始化 dp[len] = 1， if (nums[i] > nums[i - 1]) ->  dp[i] = dp[i - 1] + 1;

* 3-1 最长回文子序列
    - 动态规划： 针对某一个子串 s[i,j]
        - if s.charAt(i) == s.charAt(j) -> dp[i][j] = dp[i+1][j-1] + 2
        - else -> dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])
* 3-2 最长回文子串
    - 以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。
    - Manacher 算法








