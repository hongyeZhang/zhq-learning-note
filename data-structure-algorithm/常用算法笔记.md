
# 基本算法总结


## 基础
* 时间复杂度
* 空间复杂度

* Cn0+Cn1+Cn2+Cn3+...+Cnn = 2^n

## 数组

* 1 旋转数组中的最小数字
    - 二分查找


* 两数之和
    - 暴力求解
    - HashMap
    - 对撞指针
* 三数之和
    - HashMap 存储，然后再遍历 O(n^2)
    - 先给数组进行排序，再固定一个值做循环，然后两面两个值做双指针的对撞，根据结果移动指针
* 四数之和
     - 使用四个指针(a<b<c<d)。固定最小的a和b在左边，c=b+1,d=_size-1 移动两个指针包夹求解。
       保存使得nums[a]+nums[b]+nums[c]+nums[d]==target的解。偏大时d左移，偏小时c右移。c和d相
       遇时，表示以当前的a和b为最小值的解已经全部求得。b++,进入下一轮循环b循环，当b循环结束后。
       a++，进入下一轮a循环。 即(a在最外层循环，里面嵌套b循环，再嵌套双指针c,d包夹求解)。




* 合并k个排序数组（将k个已经排序好的数组合归并成一个有序的数组）
    - (1) 放入到一个大数组中进行快速排序 O(N*logN)
    - (2) 通过堆排序实现 O(N*logK), 构建一个K大小的小顶堆，每次取出堆顶元素，将其放入新数组的位置中。 PriorityQueue
    



## 查找
* 顺序(线性)查找
* 二分查找/折半查找
* 哈希表查找
* 二叉排序树查找





## 字符串

### 字符串匹配
* 暴力匹配
    - 时间复杂度 O(m*n)
* KMP
    - 时间复杂度 O(m+n)
    - 寻找前缀后缀最长公共元素的长度
    - 重点是next数组的求法，next数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。
* BM
    - TODO
* Sunday
    - TODO

### 字符串其他算法
* 1 替换字符串中的空格
    - 将字符串中的每一个字符按部就班的处理即可
* 2 字符串数组的最长公共前缀
    - 将字符串数组按照字典顺序排序，然后取第一个和最后一个字符串，求这两个字符串的最长公共前缀即可
* 3 最长回文串
    - 具体要求：给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串
    - 解题思路：统计字母出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。
* 4 验证一个字符串是否是回文串
    - 双指针对撞进行验证即可
* 5 找出一个字符串中的最长回文子串
    - 以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。
* 6 最长回文子序列（注意与子串的区别）
    - 动态规划，注意状态转移公式
* 7 字符串的排列（写一个函数来判断 s2 是否包含 s1 的排列）
    - 滑动窗口：不用真的去算出s1的全排列，只要统计字符出现的次数即可。可以使用一个 哈希表/数组 配上双指针来做。
* 8 字符串中第一个只出现一次的字符
    - 遍历两边字符串，第一次先统计每个字符的出现次数，存入哈希表；第二遍判断第一次出现的字母即可。
* 9 单词反转
    - 将单词 根据 " +"正则表达式进行分割，然后逆序组装。
* 10 旋转字符串
    - 在第 n 个字符后面将切一刀，将字符串分为两部分，再重新并接起来即可。
    - 注意字符串长度为 0 的情况。
* 11 判断字符串A旋转多次之后能否变成字符串B
    - return A.length() == B.length() && (A+A).contains(B);
* 12 字符串转化为整数
    - 每个字符拆解之后相加
    - 注意 int 大小溢出的情况
        - 通过 long 来解决
        - 通过 比较与 MAX_INTEGER / 10  MAX_INTEGER % 10 的大小来提前判断是否溢出 
* 13 字符串 正则表达式匹配
    - 动态规划，比较难 
    - TODO
* 14 无重复字符的最长子串
    - 动态规划，
    - 维护一个到目前位置 i 的最长的不重复子串的列表长度
* 15 字符串全排列
    - 回溯+递归
    

## 链表
* 1 删除链表节点
    - 注意判断传入的链表头节点，删除的节点是不是头结点和尾节点
    - O(1)时间复杂度
    - O(n)时间复杂度
* 2 单向链表反转
    - pre current next 三个辅助节点
    - 注意判断链表的长度，处理边界情况
* 3 单向链表反转（仅反转从 m 到 n 的部分链表）
    - 四个关键的标志点： m 之前  m  n n之后
    - 其余的按照反转链表来做即可
* 4 链表向右旋转 k 个位置
    - 找到分界点， first second 标记
    - 注意链表长度小于 k 的情况
* 5 删除倒数第K个结点
    - 快慢指针方法： fast slow preSlow 
    - 注意判断链表长度小于 k 和删除的节点是头结点的情况
* 6 求中间结点
    - 快、慢指针，直接返回 slow 即可
* 7 链表划分（给定一个单链表和数值x，划分链表使得所有小于x的节点排在大于等于x的节点之前）
    - 针对大于x和小于x的部分分别创建单链表，利用 leftDummy rightDummy 辅助节点
    - 合并以上两部分
* 8 链表求和 （写出一个函数将两个整数相加，用链表形式返回和）
    - 顺序遍历两个链表，直接将对应的元素相加即可，注意进位的处理 carry
    - 可借助 dummyNode/sentinelNode 实现
* 9 单链表排序
    - 快速排序 与数组的快速排序类似
    - 归并排序 与数组的归并排序类似（再理解一下）
    - 衍生题目： 归并两个有序链表
* 10 检测链表中是否有环
    - 快慢指针法，如果两个指针相遇，则有环
* 11 找到链表中环的入口
    - 判断是否有环
    - 计算环的长度
    - 快慢指针从头遍历，快指针领先慢指针环的长度，待二者再次相遇时，即为环的入口
* 12 判断两个链表是否相交
    - 如果两个链表相交于某一节点，那么之后的节点都是共有的，分别遍历两个链表到尾节点，判断两个尾结点是否相等即可
* 13 两个链表相交扩展（求两个无环单链表的第一个相交点）
    - 分别反转两个链表，再从头遍历，找到两个链表第一个不相等的节点的上一个节点
    - 辅助数据结构（栈），两个链表分别入栈，再从两个栈顶开始分别遍历，找到最后一个相同的节点

## 树
### 二叉树
* 1 求二叉树所有节点的个数
    - 1 + 左子树个数 + 右子树个数
    - if node == null -> return 0
* 2 求二叉树的最大深度（即求根节点的深度）
    - 1 + max(左子树最大深度 + 右子树最大深度)
    - if node == null -> return 0
* 3 二叉树的最小深度
    - 注意与最大深度区分，一定是从子节点开始计算深度，不能直接计算 min
    - (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;
* 4 二叉树的所有路径
    - 递归调用，当到达叶子节点时，将此时的路径添加到结果集中即可
* 5 判断是否为AVL树
    - 分别求出左、右子树的深度，
    - if abs(maxDepth(node.left) - maxDepth(node.right)) > 1 -> return false
    - else return 子树的递归调用
* 6 二叉树遍历（先序）
    - 辅助栈
* 7 二叉树遍历（中序）
    - 辅助栈
* 8 二叉树遍历（后序）
    - 辅助栈，注意记录遍历的次数，第二次遍历时再输出
* 9 二叉树遍历（层序）
    - 辅助结构：双端队列
* 10 从上到下分层打印二叉树
    - 在层序遍历的从基础上，记录每一层的节点个数，打印完指定数目的节点后，再打印下一层
* 11 从下到上分层打印二叉树
    - 与从上到下打印的步骤基本一致
    - 借助一个辅助的数据结构，将每一行的打印结果逆序添加到输出队列里
* 12 之字型层序遍历
    - (a) 与11题步骤一致，最后将结果数组的偶数部分逆序即可
    - (b) 通过两个辅助栈和一个添加的标志位，不同的打印顺序添加到不同的栈里面
* 13 求二叉树第K层的节点个数
    - (a) 层次遍历，遍历完 k-1 层（即此时第k层的所有节点已经入队），求此时队列的 size 即可
    - (b) 递归：一个节点的第K层的节点个数 = 左节点的第k-1层节点个数 + 右节点的第k-1层节点个数
* 14 求二叉树第K层的叶子节点个数
    - (a) 层次遍历，遍历完 k-1 层（即此时第k层的所有节点已经入队），判断此时队列中叶子节点的个数
    - (b) 与 13 的递归思路一致，但在递归的终止条件中需要判断是否是叶子节点，if leaf -> return 1; else -> return 0
* 15 判断两棵二叉树是否结构相同
    - 递归判断
        - 如果两棵二叉树都为空，返回真
        - 如果两棵二叉树一棵为空，另一棵不为空，返回假
        - 如果两棵二叉树都不为空，且节点值相同。如果对应的左子树和右子树都同构则返回真，其他返回假
* 16 求二叉树的镜像
    - 左右子树分别交换即可
* 17 判断二叉树是否镜像对称
    - isSymmetricCore(left.right, right.left) && isSymmetricCore(left.left, right.right);
    - 注意边界条件：两个节点是够为空，两个节点的值是否相等
* 18 求普通二叉树中两个节点的最低公共祖先节点
    - 如果两个节点分别在根节点的左子树和右子树，则返回根节点
    - 如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树
    - TODO 再看一下
* 19 求二叉搜索树的最低公共祖先：（性质：左子树 < 根节点 < 右子树）
    - 利用二叉搜索树的性质：
        - 如果根节点的值均小于两个节点，则递归右子树寻找
        - 如果根节点的值均大于两个节点，则递归左子树寻找
        - 如果值在二者之间，则返回根节点
* 20 求二叉树的直径 （一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。）
    - TODO
    - 左子树的深度 + 右子树的深度 + 1
* 21 由前序遍历序列和中序遍历序列重建二叉树
    - 根据前序和中序的性质进行递归求解即可
    - 
* 22 由后序遍历序列和中序遍历序列重建二叉树
    - 方法与 21 一致
    - 根据前序和后序遍历无法构造出唯一的二叉树
* 23 判断二叉树是不是完全二叉树
    - 完全二叉树是指最后一层左边是满的，右边可能慢也不能不满，然后其余层都是满的，根据这个特性，利用层遍历
    - 如果我们当前遍历到了NULL结点，如果后续还有非NULL结点，说明是非完全二叉树
* 24 树的子结构B是否是A的子树
    - 先找到尽所有可能开始的根节点,然后从该根节点开始找是不是子树，如果是直接结束，不是就看A的子树其他的节点
* 25 二叉树中和为某一值的路径
    - 暴力求解：找到二叉树中的所有路径，然后判断路径和是否符合要求
    - 回溯法：通过一个栈来维护路径上经过的节点，回到上一层时，需要将本层的节点弹出
* 26 二叉搜索树的第k个结点
    - 二叉搜索树按照中序遍历的顺序打印出来就是排好序的，按照中序遍历找到第 k 个结点就是所求的节点
* 27 寻找二叉树（每个节点包含父节点的指针）中序遍历的后继节点
    - 分三种情况进行讨论
        - 如果节点有右子树，则该节点是右子树最左的孩子节点
        - 没有右子树，且是父节点的左孩子，则父节点就是所求节点
        - 没有右子树，且是父节点的右孩子，则往上寻找，找到一个祖先节点A，是其父节点B的左孩子，B是所求节点




## 常用算法
* 动态规划
* 分治法
* 贪心求解法
* 回朔法
     - 面试题12 矩阵中的路径


* 分支限界法




### 十大排序算法
* 非线性比较类排序：非线性是指算法的时间复杂度不能突破(nlogn)，元素之间通过比较大小来决定先后顺序。
    - 交换排序
        - 冒泡排序
        - 快速排序
    - 插入排序
        - 简单插入排序
        - 希尔排序
    - 选择排序
        - 简单选择排序
        - 堆排序
    - 归并排序
        - 二路归并排序
        - 多路归并排序
* 线性非比较类排序：算法的时间复杂度能够突破(nlogn)，并且不通过比较来对元素排序。
    - 计数排序
    - 基数排序
    - 桶排序


### 动态规划
* 三个重要元素：最优子结构、边界、状态转移公式

* 1 最大子序和 （leetcode 53） 
    - 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
* 2 青蛙跳台阶问题
    - 本质是斐波那契数列问题
    - 直接动态规划求解即可
    
    
    
### 图
* 岛屿问题
* 并查集
    - 无向图的连通分量






## 典型题目 
 
* 1-1 最长公共子序列 (LCS)
    - 动态规划：
        - dp[i][j] 表示以 A[i] B[j] 为结尾的计算最长公共子序列的长度， dp[lenA-1][lenB-1] 即为最长公共子串的长度
        - if str1Arr[i] == str2Arr[j] ->  dp[i][j] = dp[i - 1][j - 1] + 1
        - else  dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
    - 输出最长公共子序列：
        - 根据 dp 矩阵，从右下角开始回溯，找到所有的子序列。
* 1-2 最长公共子串 
    - 动态规划： 
        - if str1Arr[i] == str2Arr[j] -> dp[i][j] = dp[i - 1][j - 1] + 1  

* 2-1 最长递增子序列 (LIS) 
    - 不一定连续，但是顺序不能乱
    - 动态规划：
        - L(j)={ max(L(i))+1, i<j且a[i]<a[j] }。
        - 遍历在j之前的所有位置i(从0到j-1)，找出满足条件a[i]<a[j]的L(i)，求出max(L(i))+1即为L(j)的值。
        - 遍历所有的L(j)（从0到N-1），找出最大值即为最大递增子序列。时间复杂度为O(N^2)。
    - 转化为最长公共子序列的方法
        - 将原序列 A 进行排序获得序列 A'，再求两个序列的最长公共子序列
* 2-2 最长连续递增子序列
    - 一定要连续
    - 动态规划：
        - 初始化 dp[len] = 1， if (nums[i] > nums[i - 1]) ->  dp[i] = dp[i - 1] + 1;

* 3-1 最长回文子序列
    - 动态规划： 针对某一个子串 s[i,j]
        - if s.charAt(i) == s.charAt(j) -> dp[i][j] = dp[i+1][j-1] + 2
        - else -> dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])
* 3-2 最长回文子串
    - 以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。
    - Manacher 算法








